<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript Notes</title>
    <style type="text/css">
        * {
            box-sizing: border-box;
            margin: 0;
        }

        main {
            width: 900px;
            margin: 0 auto;
        }

    </style>
</head>
<body>
    <main>
        <pre>
        <h2>Fundamentals: variables, data types, tools</h2>
        <p>
            * JavaScript is a high-level, multi-paradigm, prototype-based, object-oriented, 
                interpreted or Just In Time compiled, dynamic, single-threaded, garbage-collected, 
                programming language with first-class functions and non-blocking event loop concurrency model.
            * Authored by Brendan Eich in December 4th 1995. 

            * variable names must start with _ , letters or $ sign, should be camelCased as per convention and 
                const variables should be all caps, no gaps in between and no number at start of a variable name.

            * variable name should be descriptive.

            * variable declaration with let, const or var - (omit this one, this creates a property on window object 
                with same name as variable)

            * Reserved keywords such as new, function, name, etc. 

            * let and const for variable declaration were introduced in ES2015 or ES6, 
                - variable declared with let is mutable and block scoped.
                - variable declared with const is immutable (applicable only to primitive values)
                - we can not declare empty const variable. 
            
            * if you do not declare a variable before using it, JS will create a property on global (window) object. 
                in strict mode you can not use a variable before declaring it. 

            * inline script: within script tag 
            * external script: linked with the webpage using src attribute of script tag. 

            * ES6 or ES2015 was released in 2015. 
            * ctrl + shift + j for developer console 
            * ^ for previous command. 

            * JS has two main data types
                1. Primitive types - 7 in total 
                    numbers, strings, boolean, undefined, null, symbool, bigInt. 
                    
                2. Object type 
                    other than 7 primitive data types everything else in JS are objects. 


            * Number: are always floating point number and it is of type 'Number'. 
            * undefined: value taken by a variable that is not yet assigned to a value (not defined / empty value)
            * Null: also means empty value but different from undefined. 
            * Symbol: (ES2015) value that is unique and can not be changed. 
            * BigInt: (ES2020) Larger integers that number type can not hold. 
            * Boolean: true, false 
            * String: "this is a string", also called string leteral , they are immutable.
            
            *** Except for null and undefined, all primitive values have object equivalents that 
                wrap around the primitive values:

            * JS is dynamically typed, meaning assigned value determines the type of a variable not the variable itself. 
            * typeof variable -> returns the type of the variable. 

            * JS confusion source               [Confusion 1]
                typeof null         -> object 
                typeof undefined    -> undefined 

            * console.log(value1, value2, valueN); 
            * console.dir(obj); => to check closures and scopes
            
            * All variables from running script are available in the browser console. 
            * Operator precedence and associativity: check MDN

            * type coercion while concatenating: number with string, number gets converted to string. 
            * to avoid unexpected type coercision while using + to concatenate 
                use template literal `${ variable }` instead. 
            * template literals always expects value or expression that will generte value not statements.  
            * template literals also retains line breaks as formatted in source code.
        
        </p>


        <h2>Operators</h2>
        <p>
            * Math Operators 
                ** , * , / , %  => right to left 
                + , -           => left to right

                NOTE: 
                    1. / (division) operator performs a floating point division and return decimals i.e., 5/2 === 2.5
                    2. % (remainder) operator performs an division like other programming languages, 
                        and returns the remainder i.e., 5 % 2 === 1 
            
            * comparison operators
                > , < ,  == , >= , <= 

            * logical operators 
                && (and) , || (or) , ! (not)

            * Equality operators
                ==      (loose equality operator, type coerce the operands, string to number)
                ====    (strict equality operator, does not type coerce the operands)

            * Strict inequality operators
                !==     
            
            * assingment and compound assignment operator, 
                =               (assignment operator, right to left)
                *= , /=, +=, -= (compound assignment)

        </p>


        <h2>Type Coversion and Coercion</h2>
        <p>
            * Type conversion: manual / explicit type coversion.
            * Type coercion: automatic / implicit type conversion by JS.

            * String to number
                Number('15') => 15 (number)
                Number('Protick') => NaN (Not a number)

                *** typeof NaN === 'number'     [Confusion 2]
            
            * Number to string 
                String(25) => '25' (string)
            
            * Coercion: 
                +           -> coerce number to string if any of the operand is string and others are numbers. 
                / , * , -   -> coerce string to number

            * Boolean conversion 
                Boolean(0)  -> false
                Boolean({}) -> true // [Confusion 3]
            
        </p>


        <h2>Truthy, Falsy and Nullish values</h2>
        <p>
            Falsy values 
                1. 0            (zero)
                2. ""           (empty string)
                3. undefined    (undefined)
                4. NaN          (Not a Number, returned after string to Number conversion)
                5. null         (null)
            
            Truthy values 
                everything else is truthy value. 

            Nullish values
                1. null
                2. undefined 

                * zero, empty strings are not nullish values  
            
        </p>


        <h2>Short circuitting and logical assignment operators</h2>
        <p>
            operators used to short circuit the evaluation of an expression:

                Logical operators || and && can take any data typed value as operand and return 
                resultant value of any data type by short circuitting the rest of the evaluation of an expression. 
            
            * || ('logical or' operator): 
                if first operand is a truthy value then returns the first operand and short circuits the rest of the 
                evaluation or if all the operands are falsy then returns the last operand 

                * fails if the operand is 0 (zero), to solve this problem we have another operator - ??

            * ?? ('nullish coalescing' operator): 
                same as 'logical or' || , but works with the idea of nullish values instead of falsy values. 
                counts 0 or "" strings as truthy values as well, becaues they are not nullish

            * && (logical and operator):
                returns the first falsy operand it encounters while evaluating an expression or if 
                all operands are truthy then returns the last operand. 

            * Use cases of short circuitting 
                1. || (or) for setting default values to variable. 

                    let abc = Number(prompt('enter a number')) || 1; 

                2. && (and) for conditional statement execution 
                    abc ?? console.log(abc);

            * Logical assignment operators (ES2021)
                1. rest2.numGuests ||= 10;
                2. rest2.numGuests &&= 10;
                3. rest2.numGuests ??= 10;
            
        </p>


        <h2>Control structure</h2>
        <p>
            * if ( condition ){
                    statements; 
                } else {
                    statements;
                }
            
            * switch( var ) {

                case val1:
                case val2: 
                    statement;
                    break;

                default: 
                    statement;
                }

            * ternary / conditional operator 
                condition ? execute if true : execute if false;

                ternary operator can also be used with template literals or where a experssion or value is expected.
                In template literals you can not use if else condition because they are statements
            
        </p>    


        <h2>Loops</h2>
        <p>
            * for

                for ( let i = 0; i < arr.length; i++ ) {
                    statements;
                    continue; 
                    break;
                }


            * while 
            
                let counter = 1; 
                while (counter < 10) {
                    statements;
                    continue;
                    break;
                    counter++; 
                }
                

            * for of 

                const num = [ 10, 20, 30];
                for( item of num ){
                    statements; 
                    continue;
                    break;
                }
            
        </p>
        

        <h2>Function</h2>
        <p>
            * function declaration 

                funcName(1, 2); 
                // you can invoke function that uses declaration syntax prior to declaring the function
                // because of 'hoisting' 

                function funcName(parameter1, parameter2){
                    console.log(parameter1);
                    return parameter1 * parameter2;
                }

            * function expression 
                you can not invoke function expression before declaring them, arrow function is also a kind of 
                function expression or anonymous function, 
                
                * Anonymous function ( Function Expression )
                    const funcName = function (param1){
                        return param1 + 1;
                    };

                * Arrow function 
                    * const funcName = param1 => param1 + 1; 
                    // single parameter does not require parenthesis () 
                    // and single statement doesnt require braces {} around them

                    * const funcOther = (param1, param2) => {
                        console.log(param1);
                        return param1 * param2;
                    };

            * JS function parameter does not need let or const during declaration because whether we use them or not 
                the parameter's scope always confined within the function body. 
            
            * move line up by alt + ^ 

            * Regular functions v/s arrow functions
                *** Execution Context for arrow function do not get "arguments" objet and "this" keyword.

            * Spread operator: 
                const arr = [10, 20, 30];

                newFun(...arr); // is similer to, 
                newFun( 10, 20, 30 );

            * Rest Pattern 
                const newFun = function ( ...args ){
                    // args == [ 10, 20, 30 ]
                }
                    // can take indefinite number of arguments with rest parameter 


            * Default parameter 
                parameter that are not mandatory to invoke the function / method 

                    function foo(name, age=25, numOfPass=1, price=numOfPass * 199){
                        //function body
                    }

                    // here in function 'foo' parameter 'age' is optional, 
                    // if not provided during function call it will be automatically set to 25 

                    // an expression that includes other parameters can be set as a value to another parameter too
                    // provided that the parameter used in the expression is defined earlier in the parameter list.
                    // parameter definition order is counted from left to right
            
            * Passing arguments (Value V/S Reference)
                JavaScript is never pass by referece, we might pass referece of an object to a function but 
                not pass by reference.

                1. changing a primitive variable's value by a parameter does not change the value of the argument. 
                2. changing a passed object's property by accessing the parameter also changes the value of that 
                    property in the passed argument. 
                

            * First class function 
                1. JavaScript treats functions as first-class citizens that means functions are simpy values and 
                    it is a language feature. 

                2. Functions are just another type of object. 

            * Higher order function 
                Functions that receives or ( and ) returns a function are called higher order function. 
                This is possible because JavaScript treats functions as first-class citizens (values).

            * Function property 
                functions can even have properties such as 'name' property of a function returns it's name 
                
            * Example of Higher order functions 
                    document.element.addEventListener('event', function callMeBack ( ev ){ });
                
                here 'addEventListener' is a Higher Order function as it takes 'callMeBack' callback function as a 
                parameter. 
                In this specific case, 'callMeBack' callback function is called 'event listener' or 'event handler'
                function. 

            * what are the benefits of callback function ?
                1. Callback functions allow us to create abstraction
                2. Makes it easy to split up our code into more reusable and interconnected parts. 
                
                * What is 'Abstraction' ? 
                    Abstraction - Hide the detail of some code or implementation details because we dont really care 
                                    about all that details, this allow us to think about problems at a higher or 
                                    more abstract level.

                                    
            * Function can return other function in JavaScript and it works because of 'Closure' and this kind of 
                practice is used in functional programming. 


                const obj = {
                    name: 'Protick Roy', 
                    printGreetName: function (greetings){
                        console.log(`${greetings} ${this.name}`);
                    }
                }

                const obj2 = {
                    name: 'John Doe', 
                    printGreetName: function (greetings){
                        console.log(`${greetings} ${this.name}`);
                    }
                }

            * call()
                1. The call() method calls a function with a given 'this' value and arguments provided individually.
                2. The call() allows for a function/method belonging to one object to be assigned and called for 
                    a different object.

                        const printGreetName = obj.printGreetName; 
                        printGreetName.call(obj2, 'Hello');

                    * immediately invokes the function that has been set to a new 'this' value with call() method. 


            * apply()
                1. calls a function with a given 'this' value, and arguments provided as an array 
                    (or an array-like object).
                2. allows for a function/method belonging to one object to be assigned and called for 
                    a different object.

                        const printGreetName = obj.printGreetName; 
                        printGreetName.apply(obj2, ['Hi']);

                    * immediately invokes the function that has been set to a new this value with apply() method. 


            * bind() 
                1. The bind() method creates a new function that, when called, has its this keyword set to the 
                    provided value, with a given sequence of arguments preceding any provided when the new function 
                    is called.
                2. bind() - binds parameters beforehand and returns a new function with predefined parameters 

                    const printGreetName = obj.printGreetName; 
                    const newFunc = printGreetName.bind(obj2, 'Hello');
                    newFunc();

                * pre-defining function parameters is also called 'partial application'

                * partial application without 'this':
                    func.bind(null, arg1); 
                    func();

            * For call(), apply() and bind() the first parameter has to be an object's reference or null


            * IIFE - pattern 
                Immediately Invoked Function Expression - is a pattern invented by some devoloper which is used to 
                create a function that will be called only once and the main purpose of this was to encapsulate data 
                within a scope which can not be accessed by any other code out of this scope. 

                    (function (){ console.log('will run once')})();
                    ( () => console.log('will run once') )();

                * It is a pattern not a language feature, the same effect can be obtained by 
                    modern scoped variable i.e., 
                        {
                            let val1 = 10; 
                            const val2 = 20;
                        };

            * Closure 
                Any function always has access to the variable environment of the execution context 
                in which the function was created even after the parent execution context is popped off the 
                call stack.

                    1. VE attached to the funciton, exactly as it was at the time and place the function was created
                    2. Inner function closes over it's parent's scope. Even if the execution context is destroyed, the 
                        VE attached to that EC survived including the parent's parameters and accessible within the 
                        child / inner function. 

                    this closing action or the relationship to the parent's variable environment is called 'Closure'

                    * variable lookup first starts with the closure of a function if there is a global variable with 
                        the same name it will be replaced by closure's variables. 

                    * console.dir(function); // logs closures and scope chain
                        => [[internal property we can not access]]
            
        </p>


        <h2>Array</h2>
        <p>
            * const numbers = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]; // literal syntax
            * const numbers = new Array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
            
            * numbers.length -> 10
            * we can access and mutate array values by index as, 
                numbers[0] == 1
                numbers[4] = 100;

            * Array can contain elements of different data types and also other arrays, objects. 

            * Array methods
                1. numbers.push(11, 12, 13, 14); // adds elements (11, 12, 13, 14) at the end of the array 
                                                 // ( 'numbers' in this case)
                                                 // returns new length of the array 
                                                 
                2. numbers.unshift(0);  // adds elements in the beginning and returns new length
                3. array.pop();         // returns last element that is popped of the array 
                4. array.shift();       // removes and return first element from the array 
                5. numbers.indexOf(10)  // returns index of the element or -1 if not found
                6. numbers.includes(7)  // return true if element exists or false if not

                7. arr.entries()        // returns an iterator, where each iteration returns an array 
                                        // like [index, value];
                                        // if it returned an array instead of an iterator it would be like this, 
                                        // [ [index1, value1], [index2, value2] ... [indexN, valueN] ] 


            * Destructuring
                unpacking array elements to seperate variables. 

                const arr = [10, 20, 30];

                1. const [var1, , var3 ] = arr; 
                    // var1 == 10, var3 == 30; 
                    // we omitted the 2nd value of the array by placing a hole in the destructuring operation. 

                2. destructuring and default values 
                    const [var1, var2, var3, var4 = 100] = arr;
                    // var4 == 100
                    
                3. nested destructuring 
                    const [var1, var2, [ var3, var4]] = [ 1, 2, [10, 20]];
                    // var1 == 1, var2 == 2, var3 == 10, var4 == 20

            
            * Rest pattern 
                const [item, ...others] = [ 1, 2, 3 ];
                // item == 1, others == [ 2, 3 ]

                * Rest element must be the last element of an expression. 
                * There can be only one rest element in one destructuring statement

            * Spread Operator 
                1. const numbersArr = [ ...arr ];       // spreads the 'arr' array to 10, 20, 30
                2. const newArr = [ 100, 200, ...arr ]; // newArr == [ 100, 200, 10, 20, 30 ]

                * if we need array elements seperated by comma we use spread operator.
                * spread operator works on all iterables such as, array, string, map, set


            * Array methods extended
                let arr = ['a', 'b', 'c', 'd', 'e'];
     
                SLICE
                    console.log(arr.slice(2));
                    console.log(arr.slice(1, -2));
                    
                    // create a shallow copy of arr 
                    console.log(arr.slice());
                    console.log([...arr]);
                    
                
                SPLICE 
                    // almost same as slice() but with one exception that splice() mutates the original array
                    
                    console.log(arr.splice(2));
                    console.log(arr);
                    
                    // generally what is returned by the splice() method does not interest us rather we use splice often to delete
                    // element from an array 
                    // one most common use case is to delete the last element of an array 

                    console.log(arr.splice(-1));
                    console.log(arr);

                
                REVERSE
                    const arr2 = ['j', 'i', 'h', 'g', 'f'];
                    console.log(arr2.reverse());
                    // console.log(arr2);
                
                CONCAT
                    let letters = arr.concat(arr2);
                    console.log(letters);
                    console.log([...arr, ...arr2]);
                
                JOIN                
                    console.log(letters.join('-'));
                    // returns a string and does not mutate the original array 

                The new at() method (ES2022)
                    arr.at(0)   // returns the first element
                    arr[0]      // also returns the first element

                    1. to get the last element
                        arr.slice(-1)[0];
                        arr[arr.length -1];
                        
                        or simply, 
                        arr.at(-1); 

                    2. another use case of at() method is 
                        method chaining 
                    
                    3. at() method also works on string                
        </p>


        <h2>Set</h2>
        <p>
            collection of unique elements with no duplicate elements in them 

                const orderSet = new Set( ['pasta', 'pizza', 'risotto', 'pizza', 'pasta'] );
                    // orderset = { 'pasta', 'pizza', 'risotto' }

                    // typeof orderSet == object //tested

                const nameChar = new Set('Protick');

            * set can have mix data type elements 
            * sets are also iterables and order of element is irrelevant 
            * sets take an iterable as constructor argument. 

            * Set methods
                1. orderSet.size                // returns size/length/number of elements of the set
                2. orderSet.has('pasta')        // returns true or false if element exists in the set or not 

                3. orderSet.add('Garlic Bread') // adds new element to the set, but do not add duplicate entry: 
                                                // and returns updated Set object
                                                // only takes 1 argumnet per call

                4. orderSet.delete('Pasta')     // deletes element 'Pasta' from set 'orderSet' 
                                                // if it exists and returns true or false 
                                                // if the provided element to be deleted does not exist in the Set. 

                5. orderSet.keys()              // return a new Set iterator, alias for orderSet.values();
                6. orderSet.values()            // return values, a new Set iterator

                7. orderSet.entries()           // returns a new Set iterator in this, 
                                                // { 'element' => 'element', 'elem' => 'elem' } format. 

                8. orderSet.clear()             // deletes all elements from set. 

            * you can not retrieve a specific value from set using an index, it is an iterable so loop over it or 
                use has() to check if it contains a specific values, which is its main application other than maintai-
                ning uniqueness of elements.  
            
        </p>


        <h2>Map</h2>
        <p>
            * actually array of arrays which contains [ key, value ] pairs but it is a Map object 
                Map object is different from generic objects as 
                1. Map can have key/property which need not to be strings only.
                2. Map has built in methods like has(), delete() etc. which will not work on generic objects 
            
            * How to create Map
                1. const restMap = new Map();
                2. let nm = new Map(iterable);
                    e.g.,
                    const restMap = new Map([
                        [1, 'one'],
                        [2, 'two'],
                        [3, 'three'],
                    ]); 

                * you can make a Map object out of a 2D array which contains [key, value] pairs. 
                    let arr = [ ['key1', 'value1'], ['key2', 'value2'] ];
                    const newMap  = new Map(arr);

                * create a map from an object 
                    const newMap = new Map(Object.entries(obj));
                        // beacause Object.entries(obj) === [ ['key1', 'value1'], ['key2', 'value2'] ]

                * convert Map to an Array 
                    const keys = [ ...restMap.keys() ];         // array of Map keys 
                    const values = [ ...restMap.values() ];     // array of Map values
                    const mapToArr = [ ...restmap ];            // convert entire map to an array

                    // you have to use the spread operator because 
                    // Map.keys() , Map.values() and Map.entries() returns an iterator not an array or elements

                * typeof restMap == object 



            // JS wont stop you from doing this, but this is a map object used like a generic object 
            // Array, Map, Set all are kind of an object after all. 

                const wrongMap = new Map()
                wrongMap['bla'] = 'blaa'
                wrongMap['bla2'] = 'blaaa2'
                
                console.log(wrongMap)  // Map { bla: 'blaa', bla2: 'blaaa2' }
            //

            * Map can have mix data type values and keys 
            * Map are also iterables and order of element is preserved
            * Map take an iterable as constructor argument or no argument at all. 
            * keys are case sensitive and key type matters, '1' !== 1 

            * Map methods
                1. restMap.size                 // returns size/length/number of elements in the Map
                2. restMap.has('2')             // returns true or false if element exists in the Map whose key is '2'

                3. restMap.set('1', 'pizza')    // adds new element to the Map, but do not add duplicate entry: 
                                                // only takes 1 key value pair per call
                                                // returns updated Map Object and 
                                                // we can chanin multiple set().set() methods to insert multiple 
                                                // entries at once. 

                4. restMap.get(1)               // get element from Map 'restMap' whose key is 1;  or undefined 
                                                // if not found

                4. restMap.delete('Pasta')      // deletes element from Map 'restMap' whose key is 'Pasta'
                5. restMap.keys()               // returns a new Map iterator with only keys in it. 
                6. restMap.values()             // returns a new Map iterator with only values in it. 
                7. restMap.entries()            // returns a new Map iterator with { key => value } pairs
                8. restMap.clear()              // deletes all key value pairs from restMap.

            * We can set object and arrays as key to a map but you will need the same object / array 
                referece to get the value at that key

            * Map from generic object 

            * Map is itarable
                for ( const [key, value] of restMap ){ console.log(key, value); }
        
        </p>


        <h2>Built In Higher Order functions for Iterables</h2>
        <p>
            * forEach()

                // Array 
                    let arr = [ 10, 20, 30 ];
                    arr.forEach( function (item, index, wholeCollection) {
                        console.log(index, item);
                    } );
                
                // Map 
                    const currencies = new Map([
                        ['USD', 'United States dollar'],
                        ['EUR', 'Euro'],
                        ['GBP', 'Pound sterling'],
                    ]);

                    currencies.forEach(function (value, key, wholeCollection){
                        console.log(key, value);
                    });

                // Set 
                    const currencies = new Set(['USD', 'EUR', 'GBP', 'USD', 'EUR']);
                    currencies.forEach(function (value, _, wholeCollection){
                        console.log(value);
                    });
                        // because Set does not have key or index
                        // as per standard convention throwaway variables are declared with only single underscore, _
                    
                you can not 'break' out or 'continue' like 'for of' or other type of loops from forEach()


            * map()
                const movementsUsd = account1.movements.map((movement, i, arr)=> Math.trunc(Math.abs(movement * 1.1)));
                console.log(movementsUsd);

                * One really important distinction between forEach() and map() is if you want to create and return a 
                    new array then use map() or if you want to perform a certain action while looping through an array
                    use forEach()

            
            * filter() 
                return a new array based on boolean value returned by the callback function, 
                1. if the returned boolean value is true then the current element stays in the new array 
                2. if the returned boolean value is false then the current element is not included in the new array 

                    const deposits = account1.movements.filter(
                        (movement, index, arr) => movement > 0
                    );
                    console.log(deposits);

                    
            * reduce() 
                reduces or boils down the whole array into a single value, 

                    const min = arr.reduce(function (accumulator, currentItem, index, wholeCollection){
                        return accumulator <= currentItem ? accumulator: currentItem; 
                    }, arr[0]);

                    const sum = arr.reduce(function (sum, item, i, arr){
                        return sum += item;
                    }, arr[0]);
            
            * chaining methods 
                const interest = movements
                    .filter(mov => mov > 0)
                    .map(mov => (mov * 1.2) / 100)
                    .filter(intrst => intrst >= 1)
                    .reduce((acc, intrst) => acc + intrst, 0);

                1. Do not over use it 
                2. Do not use any methods in the chain that mutates the original array such as reverse() and splice()


            const arr = [1,2,3,4,-1,-2,-3];
            * find() 
                const account = accounts.find((ac, i, wholeCollection) => ac.owner === 'Jessica Davis');
                console.log(account);
                    // returns the 'first matched' 'element' from an array
                    // often returns object from an array of objects based on condition
                    // unlike filter it does not return an array of elements 

                    let res = arr.find((item, index, arr) => item >=3 );            
                    console.log(res) === 3               

            * findIndex( (item, i , wholeCollection) => return item > 100);
                // return index of an item from an array based ono codition in the callBack function
                res = arr.findIndex((item, i, arr) => item >= 3);
                console.log(res) === 2
    
            * some() 
                    similer to arr.include(1); // but check is based on equality if any array elements === 1

                    // returns true or false based on codition in callback function
                    // based on any type condition
                    let res = arr.some((item, i, arr) => item < 0);
                    console.log(res) === true
            
            * every() 
                // check if all elements satisfies condition and returns true or false
                    let res = arr.every((item, i, arr) => typeof item === 'number');
                    console.log(res) === true

            * you can write the callback function seperately and pass the function as callback to any methods that 
                expects a callback

            * flat() 
                flattens a nested array to array of single elements 
                    let arr = [ [1, 2], 3, 4, 5, [6, 7, 8] ];
                    arr = arr.flat(); // default depth level is 1 

                you can flatten arrays nested more than 1 level by
                    arr.flat(2);

            * flatMap(mapping condition)
                map() and then flat() the resultant array is fairly common acction you can simpley this process of 
                calling map and then flat() by flatMap() method 
                
                NOTE: flatMap() can go only 1 level deep so if you need to go more than 1 level deep you need to use 
                flat() method anyway. 

            * Built in JavaScript sort methods 
                * sort()
                    let arr = ['Protick', 'Sajib', 'Apu', 'Mahbub', 'Ahnaf'];
                    arr.sort(); 
                    arr === ['Ahnaf', 'Apu', 'Mahbub', 'Protick', 'Sajib']
                        // mutates the original array   

                    let arr = [1,2,3,4,-1,0,-2];
                    arr.sor();
                    arr === [-1, -2, 0, 1, 2, 3, 4]
                        // sort() method works based on string so 
                        // numbers are converted to string then sorts 
                        // that is why first element is -1 not -2 
                        // we can fix this by passing a callback function

                    arr.sort(function (curr, next){ 
                        // parameter order does not matters curr and next parameters can hold either first or second element 
                        // interchangably based on array data 

                        // return == 0 does not swap //tested in V8 
                        // return < 0 swaps , curr next => next curr
                        return next < curr ? -1 : 1;
                    });

                    lets optimize, 
                    arr.sort((curr, next) =>  curr - next); // if next > curr then next - curr = -n => swap => curr next
                                                            // array sorted in ascending order
                    arr.sort((curr, next) => next - curr); // array sorted in descending order 

                    thats all for now, sort() is messed up if you think about how it works
                    Explain me this example, 
                        let arr = [-4, -1, -2, -3].sort((curr, next) => next - curr); // descending order -1 -(-4) => 3
                            // arr === [-1, -2, -3, -4]

                    let arr = [-4, -1, -2, -3];
                    arr.sort((curr, next) => { 
                            console.log(`Current: ${curr}, Next: ${next} `); 
                            console.log(`res: ${next - curr}`); 
                            return next-curr 
                        });

                    console.log(arr);

                    * Also two parameters that sort function have can receive objects if the array 
                        is an array of objects
                    [Confusion 4]
                
                * Generate Arrays programmatically 
                    * Array of empty elements 
                        let x = new Array(7);  ==== [ empty x 7 ] // array of 7 empty elements 
                        * no methods can be called on array of empty elements other than the 'fill()' method.
                        
                        * x.fill(value, startIndex, endIndex);                 
                            // mutates the original array 

                    * from()
                        Array.from({length: 7}, callbackThatActsLikeMap(item, i, arr){ return i + 1; });
                        // returns a new array === [ 1, 2, 3, 4, 5, 6, 7 ]; 

                        * was intially introduced to create array from array like structures, such as, strings, 
                            maps, sets and iterables

                        * use case 
                            let valuesFromDom = Array.from( document.querySelectorAll('.movements__value'), 
                                                            (elem) => elem.textContent.replace('€', '') );

                            1. gather data from dom and put in an array 
                            2. covert node list to an array of values 

                            you can also covert DOM node list to an array by, 
                                [ ...document.querySelector('.query') ];
                                
                *** Be comfortable with filter() method and also remember filter() method creates new array based on 
                        original array and condition defined in callBack function 

                    * also callBack function can be defined else where and passed to these array methods which expects
                        a callback functions; but remember to match the arguments and parameters as we dont call them 
                        but the higher order array methods
        </p>        


        <h2>Object</h2>
        <p>
            * object declaration
                const obj = {
                    firstName: 'Protick', 
                    lastName: 'Roy', 
                    age: 2022 - 1994, 
                    friends: [ 'one', 'two', 'three' ],
                };
                // this is called object literal syntax 

                 let obj = new Object(); // obj of generic Object class

            * accessing object properties by . (dot) and [] (bracket) notation
                obj.firstName => 'Protick'
                obj['lastName'] => 'Roy' 
                // notice the quoation mark around the property name, single and double quotes both are permitted

            * object property accessor . (dot) => associativity left to right

            * Adding new property to object by . and []
                obj.country = 'Bangladesh';
                obj["profession"] = 'Software Developer';

            * Object method
                function declaration inside an object does not work so we need to store the function (expression) in a 
                property.

                const obj: {
                    getAge: function returnAge(){ 
                        // function name returnAge is unnecessary here, we can omit it like the following function
                        return this.age;
                    }, 

                    getFirstName: function (){
                        return this.firstName;
                    },

                    printStr: (str) => console.log(str), 

                    // but the following wont work 
                    function howDoYouCallMe(){
                        console.log('because I am inside an object but do not belong to any property'):
                    }
                };
            
            * Object literal's braces do not mark a block scope. 
            * If a property is not available in an object it is simply undefined. 
            
            *** if an object method defines a ragular function or function expression within itself and invokes the 
                newly created inner function, it is considered regular function call so 'this' is set to undefined 
                for the inner function. 
                    1. You can use arrow function as arrow function's 'this' is set to 'parent's this'
                    2. or you can set a local variable to 'this' and use that local variable within the inner function.
                    
            * Object.assign({}, srcObj); 
                => creates a shallow copy of srcObj and  returns a new object; merges srcObj with empty object;
                => To make a deep copy of an object we use third party libraries like lodash 
                        
            * Method borrowing
                objNew.newProperty = oldObj.method;  
                    // now objNew has oldObj.method in it. 

            * Primitives vs Objects 
                * primitive type 
                    Number, String, Boolean, Undefined, Null, Symbol, BigInt 
                    stored in Execution Context and EC is placed in the callstack 

                * Object 
                    object literal, Arrays, Functions 
                    stored in HEAP

                * variable stores memory address. 
                    1. changing value of a primitive type variable changes the memory address to a new location
                        where new value is stored. 
                        
                    2. Primitive type variable stores memory address where actual value is stored. 
                    
                    3. Reference type variable stores memory address which in turn stores memory addres of the object 
                        in the HEAP. Because object is too big to store in call stack. 
                        so copying a object to another variable shares the same memory address from the HEAP. 
                        which leads to unwanted property value modification.

            * Destructuring Objects 
                As object properties do not retain the order in which they are placed in the object literal we need to 
                specify the object's specific property name to destructure it. 

                let firstName = "John"; 
                let lastName = "Doe";

                const obj = {
                    firstName: 'Protick', 
                    lastName: 'Roy', 
                    age: 2022 - 1994, 
                    friends: [ 'one', 'two', 'three' ],
                    likes: {
                        'weather': 'rainy', 
                        'day': 'shiny'
                    }
                };

                const { firstName:fn = 'John', lastName:ln = 'Doe', likes:{ weather:w, day:d } } = obj;

                // 'firstName' => object property 
                // 'fn' => new variable that holds the value of obj.firstName; 
                // fn = 'John' => default value 'John' 
                // w and d destructuring nested obj 'likes'
                
                * mutating pre defined variables while destructuring, 
                    ({firstName, lastName} = obj);

                * Use cases of object destructuring are many but one specific use case can be, 
                    object as argumend and destructure the object parameter to unpack arguments. 

            * Spread operator
                since ES2021 spread operator is also usable with objects, though they are not iterables
                we can use spread operator to make a shallow copy of an object. 

            * Enhanced Object Literals 
                1. Including variable in an object with the same property name as the variable can be done as, 

                    const newVar = 10;
                    const obj = {
                        newVar, // same as newVar: newVar, 
                    };

                2. Adding method to an object without function keyword and property name, 
                    
                    const obj = {
                        printStat ( param1 ){
                            console.log(param1);
                        }
                    };

                3. Computed property name, 

                    const obj = {

                        // third brackets are a must to compute a property name. 
                        [ `day-${ 4 + 5}` ]: { 

                            //nested object
                        }, 
                    };
            
            * Optional chaining (ES2020) 
                '?' operator 

                1. if property exists
                    restaurant.openingHours.mon?.open
                    if 'mon' property exists on 'restaurant.openingHours' then perform restaurant.openingHours.mon.open
                    if it does not then return undefined. 

                2. we can use optional chaining operator with nullish coalescing operator to check if, 
                    a) Method exists, 
                        const res = obj.method?.() ?? 'method does not exist or returned nullish value';
                        
                    b) array exists or empty 


            * Looping Objects 
                1. Object property names are also called keys
                    Object.keys(obj); 
                        // returns array of properties of obj 
                
                2. Object property values
                    Object.values(obj); 
                        // return array of values of obj 

                3. Object keys and values 
                    Object.entries(obj); 
                        // objects are not iterable so we use this method to make it iterable
                        // returns [ [key1, value1], [key2, value2] ... [keyN, valueN] ] ; 
                        // an actual array unlike array.entries() which returns an iterator object;
            
        </p>


        <h2>String</h2>
        <p>
            * String is an array of characters 
                const str = "This is a string";

            * strings are primitive values so it is impossible to mutate them 

            * String Methods 

                1. str.indexOf('i'); 
                    // returns 2, position of 'i' in the string 'str'
                    // return first occurance position or -1 if no match found

                2. str.lastIndexOf('i'); 
                    // returns 13, position of 'i' in the string 'str'
                    // return last occurance position or -1 if no match found

                3. str.slice(5);
                    // slice the string starting at position 5 (inclusive) and return the resultant string 
                    // from position 5 to the end; returns a new string => "is a string"

                    * extract the first word 
                        let firstWord = str.slice( 0, str.indexOf(' ') );
                            // returns a new string => "This"

                    * extract the last word 
                        let lastWord = str.slice(str.lastIndexOf(' ') + 1 );
                            // returns a new string => "string"

                    * start slice position count from the end
                        let newStr = str.slice(-6);
                            // negative count starts from -1, 
                            // returns a new string => "string"

                4. str.toLowerCase(); // "this is a string"
                5. str.toUpperCase(); // "THIS IS A STRING"

                    * capitalize a string 
                        const str = "pRotick";
                        const strLower = str.toLowerCase();
                        const strCapitalized = str[0].toUpperCase() + strLower.slice(1); 
                            // strCapitalized === "Protick"
                    
                    * comparing emails 
                        i)   Convert it to lower case 
                        ii)  Remove white spaces 
                        iii) compare 


                6. str.trim(); 
                    // removes white spaces and \n from start and end of a string 
                    
                    i) str.trimStart() // from start 
                    ii) str.trimEnd()  // from end 


                7. str.replace('what to replace', 'with what');
                    // replaces the first occurance and returns a new string

                    // to replace all matching occurance you can use regex 
                        str.replace(/This/g, 'dis');
                            // here 'g' denotes global flag for the regex expression enclosed by / /

                8. str.replaceAll('This', 'Dis');
                    // replaces all the 'This' word with 'Dis' in the string 'str'
                    // returns a new string 
                
                
                    const plane = 'Air320neo';
                9. plane.includes('Air320'); // returns true (or false)
                10. plane.startsWith('Air'); // returns true (or false)
                11. plane.endsWith('320');   // returns true (or false)
                
                    const x = 'a+very+nice+string'; 
                12. const words = x.split('+');         // split
                        // returns an array of strings 
                        // words === [ 'a', 'very', 'nice', 'string' ];
                    
                13. let joinedString = words.join(' '); // join
                    // returns new string by joining array elements by parameter passed to .join() method 
                    // joinedString === 'a very nice string' 

                14. Padding a string 
                    let str = 'This is a line of text';

                    let paddedStr = str.padStart(30, '+');
                    let paddedStr = str.padEnd(30, '-');

                    let emptyPadStrStart = str.padStart(30, ' ');
                    or, 
                    let emptyPadStrStart = str.padStart(30);

                        // returns new string after adding padding, 
                        // total length of the new string including padding will be exactly 30 characters 
                
                15. Repeat a string n times. 
                    str.repeat(n);
                    // returns a new string repeating 'n' times;
                
        </p>

        <h2>Numbers Dates Timers and Internationalizations</h2>
        <p>
            * Number 
                1. All numbers are represented as floating point numbers or decimals no matter 
                    if we write them as integers
                    console.log(10 === 10.0) // true

                2. Numbers are 64 bit base 2
                3. Certain numbers are very difficult to represent in binary such as 0.1
                    console.log(0.1 + 0.2) // 0.30000000000000004 [Confusion 5]
                    console.log( 0.1 + 0.2 ==== 0.3 ) // false [Confusion 6]

                * JavaScript can not really do precise sceientific calculation even if it also tires to round off number
                    behind the scene. 
                
                * String to Number conversion 
                    1. Number('23') // 23
                    2. +'23'        // 23 , by coercion 
                
                
                * Parsing 
                    works with string that starts with numeric characters
                        Number.parseFunction('25String', radix or base); 
                        radix 
                            An integer between 2 and 36 that represents the radix (the base in mathematical 
                            numeral systems) of the string. Be careful—this does not default to 10.

                    Integer
                        * Number.parseInt('30px', 10)       // 30
                        * Number.parseInt('30.5rem', 10)    // 30
                        * Number.parseInt('e23', 10)        // NaN 

                    Float 
                        * Number.parseFloat('250.50rem') // 250.50
                        * parseFloat('250.50rem') // also works but Number.parseFloat() is encouraged. 

                * Check if Not A Number (NaN)
                    both NaN == NaN and NaN === NaN evaluate to false. [Confusion 7]
                    The isNaN() function provides a convenient equality check against NaN.
                    * Number.isNaN('2')             // false
                    * Number.isNaN(Number('str'))   // true
                    * Number.isNaN( 23 / 0 )        // true

                Rather check for if the number is finite, that returns expected value if a value is a number or not
                * Check if a value is a Number
                    * Number.isFinite(10)       // true
                    * Number.isFinite('10')     // false    it is a string 
                    * Number.isFinite(+'20X')   // false    it is NaN 
                    * Number.isFinite(10 / 0)   // false    it is Infinity
                    
                * Check if a value is an Integer 
                    * Number.isInteger(10)      // true
                    * Number.isInteger(10.0)    // true
                    * Number.isInteger('20')    // false    it is string 
                    * Number.isInteger(10.5)    // false    it is double and has decimal point values 
                    * Number.isInteger(10 / 0)  // false    it is infinity

                    *** Important 
                        https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
                        [Confusion 8]


                * JavaScript has singular concept of number values which is called 'number', 
                    let x = Number.parseFloat(10.1);
                    let y = Number.parseInt(10.1);
                    typeof x === typeof y
                    >> true [Confusion 9]

                * Infinity value 
                    there is a special mathematical value in JavaScript which is 'Infinity'
                * Note: typeof NaN === 'number' // true

                * Numeric Seperator (ES 2021)
                    _ (underscore) to seperate numeric characters in a number to enhance readablity 
                    
                    conditions: 
                        1. always between two digits 
                        2. not start or not at the end and not before or after the decimal point 
                        3. not two or more consecutive underscores
                    
                    * Number('230_000')     // NaN  only works with numbers not strings 
                    * parseInt('230_000')   // 230  ignores the rest after the numeric seperator after 
                                            // the underscore as it is a string

                * BigInt (ES 2020) (primitive)
                    Numbers are 64 bits of which 53 bits are used to store the number and the rest are used to 
                    store the position of the decimal point.

                    * Biggest Number JavaScript can represent, (safely)
                        console.log( 2 ** 53 - 1) // -1 because 0 is also a number // 9007199254740991
                        the max number is also stored in Number.MAX_SAFE_INTEGER in Number namespace 

                    * To represent and work with big numbers which are more than 53 bits long we can use 'n' with it
                        let bigIntNumber = 90071992547409919007199254740991n;

                        we can also create a bigInt by, 
                        let bigIntNumber = BigInt(90071992547409919007199254740991n)

                    * Operations
                        we can perform all the operations same as regular numbers but we can not mix them 
                            1. console.log(90071992547409919007199254740991n * 2n); // okay
                            
                            2. console.log(90071992547409919007199254740991n * 2); // Exception
                                solution 
                                console.log(90071992547409919007199254740991n * BigInt(2));

                        Exceptions: 
                            1. console.log(20n > 15);       // true     because it type coerce the 20n to 20
                            2. console.log(20n === 20);     // false    because strict equality does not type coerce 
                               console.log(20n == 20);      // true     because it type coerce 
                               
                            3. console.log( 20n + 'is really huge') // 20 is really huge 
                            
                            4. Math library functions do not work with bigint 

                            5. console.log( 10n / 3n )      // 3n               cuts the decimal part off 
                               console.log( 10 / 3 )        // 3.3333333333333
            
            * Dates
                * Creating dates - 4 Ways 
                    1. Current date and time 
                        new Date();                         // current date time timezone 

                    2. parse date from a date string 
                        new Date('June 10, 2021');          // not so reliable 

                    3. new Date by providing - year, month, date, hour, minute, seconds 
                        new Date(2021, 5, 10, 16, 45, 30);  // Month is 0 based, 0 - 11 

                    4. timestamp 
                        Milliseconds passed after initial UNIX time - 1st January 1970
                        new Date(0);                        // Thu Jan 01 1970 06:00:00 GMT+0600 
                                                            // (Bangladesh Standard Time)

                    * Date auto corrects itself meaning, if you provide 31 days for the month of November to 
                        the Date() constructor it will automatically corrects itself by adjusting the month and day
                        to December 1.

                * Date is also an object so we get methods 
                    let today = new Date();
                    let now = Date.now();

                    1. today.getFullYear();     // .getYear() is also available but not recommended to use. 
                    2. today.getMonth();        // 0 - 11, because Month is 0 based in JavaScript [Confusion 9]
                    3. today.getDate();         // day of the month [Confusion 10]
                    4. today.getDay();          // day of the week  [Confusion 11]
                    5. today.getHours();
                    6. today.getMinutes();
                    7. today.getSeconds();
                    8. today.toISOString();     // 2022-06-14T11:59:00.389Z
                    9. today.getTime();         // 1655207940389 // timestamp from a date
                    10. Date.now();             // 1655208063477 // timestamp of the moment

                    * Set methods are also available to set year month date hours minutes seconds 
                    * Set methods also auto corrects 
                    
        </p>        


        <h2>Dom and events </h2>
        <p>
            * DOM - Document Object Model : Structured representation of HTML document. 
                A tree structure that represents a family tree, where "document" is the 
                first parent / root / entry point 

                    document --> html --> head --> title --> text
                                  |         
                                  |
                                 body --> section --> nav --> ul --> li --> text 
                                  |
                                  |
                                main --> p --> text 
                                  
                whatever is in the html also has to be in the DOM. 
                DOM also includes CSS styles. 

            * Adding callback on events 
                * document.querySelector('query').addEventListener('event', callbackFunction () {});
                * document.element.addEventListener('event', callbackFunctionValue);
                * document.getElementById('element id without the # ').addEventListener('event', callback);

            * Changing styles of elements 
                * document.querySelector('body').style.backgroundColor = 'green';

            * Add, remove, check, toggle class of an element via
                
                * document.querySelector('.element-class').classList.add('paragraph__text--white'); 
                    // adds specified class, if the class has already been added to that element, do nothing. 

                * document.querySelector('.element-class').classList.remove('paragraph__text--white'); 
                    // removes specified class if present on the selected element or do nothing if not. 

                * document.querySelector('.class').classList.contains('.another-class'); 
                    // returns true or false if "another-class" is present in the selected element. 
                
                * document.querySelector('#id').classList.toggle('active'); 
                    // toggles the specified class "active"; adds or removes it from the selected element. 

                
            * querySelector vs querySelectorAll 
                * querySelector only selects the first matching occurance in the dom and returns the element.
                * querySelectorAll selects all matching occurance in the dom and return an array of elements. 

            * Selecting an element via getElementById is a little faster than querySelector. 

            * The DOM and DOM methods are part of the WEB APIs, they are not part of JavaScript. 
            
            *** Not just rely on the DOM to hold our data, make data relevant to application 
                always to be available in the code. 

            * Events 
                * keyboard events: they are global events because they do not happen on one specific event 
                    so we listen to the whole document 
                    
                    document.addEventListener('keydown', function (ev) {
                        if ( ev.key === 'Escape') {
                            statements;
                        }
                    });

                * which key is pressed is stored on the event itself.
                * when an event occurs JS call the callback function / event listener and passes the 
                    event as an argument to it. Inside the callback function the 'this' keyword always refers to 
                    the element itself by default but you can change that with 
                    callbackFunction.bind(obj);
            
        </p>


        <h2>Libraries and methods</h2>
        <p>
            Math
                * Math.random() => 0.0000 to 0.9999
                
                * generate a random number between 1 to 6, 
                    Math.trunc(Math.random() * 6) + 1; // Math.trunc() truncates the decimal part 

                * Math.abs( -100 ) => 100

                * square root 
                    Math.sqrt(25)   // 5

                    the same can also be done by, 
                    25 ** (1/2)     // 5

                * Cubic root 
                    8 ** (1/3)      // 2

                * Maximum value 
                    Math.max(5, 8, 23, 11, 2)   // 23
                    * also type coerce the values from strings to numbers
                    * does not do parsing such as, from string to numbers 
                
                * Minimum value 
                    Math.min(5, 8, 23, 11, 2)   // 2

                * Math library also has some constants such as, 
                    Math.PI === 3.141592653589793

                * Generalized random integer generator function
                    const randomInt = (min, max) => Math.floor( Math.random() * (max - min) + min);            
                
                * Rounding Integers
                    * All of these methods do type coercion such as string to number

                    Round to nearest integer
                        Math.round(23.3)    // 23
                        Math.round(23.9)    // 24

                    Ceilling to Integer 
                        Math.ceil(23.3)     // 24
                        Math.ceil(23.9)     // 24

                    Flooring to Integer 
                        Math.floor(23.3)    // 23
                        Math.floor(23.9)    // 23
                        Math.floor(-23.3)   // -24  for negative values floor rounds down 

                    Truncate the decimal part 
                        Math.trunc(23.3)    // 23
                        Math.trunc(23.9)    // 23
                        Math.trunc(-23.3)   // -23

                * Rounding decimals 
                    (2.7).toFixed(0)    // '3'      always returns a string not a number 
                    (2.7).toFixed(3)    // '2.700'  pads remaining decimal points with '0'
                    (2.345).toFixed(2)  // '2.35'   same as flooring and ceilling in mathematics
                    +(2.345).toFixed(2) // 2.35     convert the result to a number 

        </p>


        <h2>How JS works behind the scene</h2>
        <p>
            * Just in time compiled language so, each statement is parsed and compiled to machine code 
                and executed immediately by JS Engine 

            * Execution steps
                1. Parse and create AST (Abstract Syntax Tree)
                2. Compile to binary 
                3. Execution in call stack 
                4. Optimize and return to step 2

            * JS Engine 
                1. HEAP 
                2. Call Stack 

            * JS Runtime
                JS Engine + WEB APIs + Callback Queue

            * Steps 
                1. Exactly One global execution cotext is created (creation phase)
                2. All top level code or code that are outside of any function are executed in the global 
                    Execution Context
                3. One execution context per function call is created (creation phase) and placed in the call 
                    stack and executed then pop out the execution context when the function returns ( or execution is 
                    finished for the Execution Context )
                4. After all the function are done executing the engine will keep waiting for callback functions 
                    to arrive. 

            * Execution Context 
                Environment in which a piece of JavaScript is executed. Store all the necessary information for some
                code to be executed. 

                An EC consists of, 
                    1. Variable Environment (VE) => let, const, var, function, arguments, objects 
                    2. Scope Chain 
                    3. this => value of this keyword for the context 

                    all these elements that make up the EC are generated during creation phase
                    
                    *** EC for arrow function do not get "arguments" objet and "this" keyword.

            * Scoping 
                JavaScript uses lexical scoping, meaning scoping is controlled by placement of functions and 
                blocks in the code. 
                Scoping is how program's variables are organized and accessed. 

                * scope: 
                    space or environment in which certain variable is declared 
                    There are 3 types of scope, 
                        1. global scope - outside of any function or block; accessible everywhere. 
                        2. function scope - inside function, also called local scope and variables declared inside it 
                                are called local variables. 
                        3. Block scope (ES2015) - Only applies to let and const variables. Functions are also block 
                            scoped. Function declared inside a block is only accessible inside that block. 

                        * Variables declared with 'var' are function scoped or the global scoped 

                * scope chain: 
                    Every scope has access to all the variables of it's (outer) parent's scope.     
                    This rule also applies to function parameters. 
                
                * Variable look up: 
                    If one scope need to access a variable and it is not present in the current scope then it 
                    will look up in the scope chain and see if it can find the variable in one of its parent's scope. 

                * Parent scope does not access child scope. 
                * Scope chain also applies to block scope. 
                * Variables with same name in current scope overrides variables from parent's scope. 

            * Hoisting 
                Before execution, code is scanned for variable declartions and for each variable a new property is 
                created in the Variable Environment Object of the Execution Context.

                * let, const variables and function expression or arrow functions that are stored in a variable 
                    that is declared with let and const are placed in Temporal Dead Zone (TDZ).
                    That is why we can not use them prior to declration. On the other hand, we can invoke 
                    function that uses a function declaration syntax and also variables that are 
                    declared with 'var' keyword. 

                * TDZ 
                    Temporal Dead Zone starts at the begining of the scope and end at the line it is defined. 

                    * why TDZ ? 
                        1. Makes it easier to avoid and catch errors. 
                        2. Makes const variables actually work. 
                        we can not declare an empty const variable. 

                * Why hoising ?
                    1. to make functions accessible that uses function declaration syntax. ***
                    2. var hoisting is just a byproduct. 
                    
                * 'var' variables are hoisted with 'undefined' value. 
                * 'var' variables are created as a property on the global 'window' object. 

                * function expression / arrow functions declared with var will be hoisted and value set 
                    to those variables are 'undefined'
                    => undefined(); // imagine what will happen. 

                * Pitfall of hoisting 
                    if you use 'var' variables as condition parameter prior to definition. 

            * 'window' is the global object of JavaScript in the browser, each per window. 

            * The 'this' keyword
                special variable that is created for every execution context (EC).

                1. In event listener / event callback => this === 'the element itself on which the listener 
                    is bind to'
                2. obj.method() => this === obj (on which the method is called) 
                3. Function with declrative syntax in global scope => this === 'undefined'
                4. Arrow function => this === 'this of the function's parent'

                * without strict mode 'this == window'

        </p>


        <h2>Important general information</h2>
        <p>
            * Enabling strict mode
                'use strict';

                enabling strict mode will prohibit you from using variable without declaration with let const or var.
                also reserves a set of keywords that are decided to be implemented in future version of JS

            * transpile and polyfill JS source code with babel to support older browser upto browsers from 2009 or ES5; 
            * Statement: unit of a instruction set.
            * Expression: Operation that produces value. 

            * which data structure to use
                collection of data --> data structure --> (simple list) --> (manipulate ordered data) --> Array 
                                               |                 |
                                               |                 |
                                               |         ( high performance, unique data ) --> Set
                                               |
                                        (key value pairs)
                                               |
                                               |
                                               |--> (easy to write)     --> Object 
                                               |--> (easy to iterate)   --> Map 

                * Data from WEB APIs are almost always JSON formatted that is similar to JS Object. 
                * Array of Objects are more comon. 
                * we should use array or sets to store a list of items and when we do not need to describe them. 
                * Use array when we need to manipulate list items and there are tons of useful array methods. 
                * Use Set when we need list of only unique elements
                * Use Set when high performance is really important
                * Use Set to remove duplicate items from Array
            
            * Object V/S Map 
                1. Object 
                    * when we need to include functions. 
                    * when working with JSON. 
                    * when key/properties must be a string. 
                    * Easy to access values with . and []
                
                2. Map 
                    * When you need to simply map key to values and you dont need any method in it at any point. 
                    * when you need keys to be of any type such as string number boolean object function array set etc. 
                    * Map iteration
                        for (const [key, value] of mapObj){

                        }

            * Why method call on primitive type such as 'string' works ?
                Because of "Boxing"

            * Boxing
                Boxing is wrapping a primitive type value inside an object when JS engine sees a method call on a
                primitive type value it wraps it in an appropriate object and performs the method call and then finally
                returns the resultant primitive value. 

            * In EU , is used as decimal seperator. 
            * In US . is used as decimal seperator.

        </p>


        <h2>Development Debugging and Problem solving tips</h2>
        <p>
            Problem solving techniques: 

                * Ask right questions until you understand what is really being asked for, 
                    figure out the result you really want to achive
                    understand the input and output first then figure out the path from input to output.
                * Divide and conquer, divide the entire problem into sub problems
                * Research and solve sub-problems until you hit a wall, if you do, google. 
                * Write pseudo code / comments / sentence (what you want to happen in steps) before coding. 
                * Draw flowchart before coding.


            Debugging: 

                * VScode has a built in JS debugger use it to set breakpoints and step through statements. 
                * chrome dev tools > source > breakpoint -> debug (sometimes does not stop at breakpoint)
                * add the following statement in the source code to halt execution
                    debugger; 
                    or, 
                    debug(functionName);

                * console.warn();
                * console.error();
                * console.table(obj);
                * console.dir(functionValue):

                debugging framework
                    1. Identify bug -> automated tests 
                    2. Find bug -> finding the underlying reason => logical, structural etc
                    3. Fix bug 
                    4. Prevent bug
        
        </p>

        </pre>
    </main>
    <script src="script.js"></script>
</body>
</html>