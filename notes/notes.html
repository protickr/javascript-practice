<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript Notes</title>
    <style type="text/css">
        * {
            box-sizing: border-box;
            margin: 0;
        }

        main {
            width: 900px;
            margin: 0 auto;
        }

    </style>
</head>
<body>
    <main>
        <pre>
        <h2>Fundamentals: variables, data types, tools</h2>
        <p>
            * JavaScript is a high-level, multi-paradigm, prototype-based, object-oriented, 
                interpreted or Just In Time compiled, dynamic, single-threaded, garbage-collected, 
                programming language with first-class functions and non-blocking event loop concurrency model.
            * Authored by Brendan Eich in December 4th 1995. 

            * variable names must start with _ , letters or $ sign, should be camelCased as per convention and 
                const variables should be all caps, no gaps in between and no number at start of a variable name.

            * variable name should be descriptive.

            * variable declaration with let, const or var - (omit this one, this creates a property on window object 
                with same name as variable)

            * Reserved keywords such as new, function, name, etc. 

            * let and const for variable declaration were introduced in ES2015 or ES6, 
                - variable declared with let is mutable and block scoped.
                - variable declared with const is immutable (applicable only to primitive values)
                - we can not declare empty const variable. 
            
            * if you do not declare a variable before using it, JS will create a property on global (window) object. 
                in strict mode you can not use a variable before declaring it. 

            * inline script: within script tag 
            * external script: linked with the webpage using src attribute of script tag. 

            * ES6 or ES2015 was released in 2015. 
            * ctrl + shift + j for developer console 
            * ^ for previous command. 

            * JS has two main data types
                1. Primitive types - 7 in total 
                    numbers, strings, boolean, undefined, null, symbool, bigInt. 
                    
                2. Object type 
                    other than 7 primitive data types everything else in JS are objects. 


            * Number: are always floating point number and it is of type 'Number'. 
            * undefined: value taken by a variable that is not yet assigned to a value (not defined / empty value)
            * Null: also means empty value but different from undefined. 
            * Symbol: (ES2015) value that is unique and can not be changed. 
            * BigInt: (ES2020) Larger integers that number type can not hold. 
            * Boolean: true, false 
            * String: "this is a string", also called string leteral , they are immutable.
            
            *** Except for null and undefined, all primitive values have object equivalents that 
                wrap around the primitive values:

            * JS is dynamically typed, meaning assigned value determines the type of a variable not the variable itself. 
            * typeof variable -> returns the type of the variable. 

            * JS confusion source               [Confusion 1]
                typeof null         -> object 
                typeof undefined    -> undefined 

            * console.log(value1, value2, valueN); 
            * console.dir(obj); => to check closures and scopes
            
            * All variables from running script are available in the browser console. 
            * Operator precedence and associativity: check MDN

            * type coercion while concatenating: number with string, number gets converted to string. 
            * to avoid unexpected type coercision while using + to concatenate 
                use template literal `${ variable }` instead. 
            * template literals always expects value or expression that will generte value not statements.  
            * template literals also retains line breaks as formatted in source code.

            * Global variables from other scripts are accessible in our script provided that other scripts are loaded 
                in the browser prior to ours. 
        
        </p>


        <h2>Operators</h2>
        <p>
            * Math Operators 
                ** , * , / , %  => right to left 
                + , -           => left to right

                NOTE: 
                    1. / (division) operator performs a floating point division and return decimals i.e., 5/2 === 2.5
                    2. % (remainder) operator performs an division like other programming languages, 
                        and returns the remainder i.e., 5 % 2 === 1 
            
            * comparison operators
                > , < ,  == , >= , <= 

            * logical operators 
                && (and) , || (or) , ! (not)

            * Equality operators
                ==      (loose equality operator, type coerce the operands, string to number)
                ====    (strict equality operator, does not type coerce the operands)

            * Strict inequality operators
                !==     
            
            * assingment and compound assignment operator, 
                =               (assignment operator, right to left)
                *= , /=, +=, -= (compound assignment)

        </p>


        <h2>Type Coversion and Coercion</h2>
        <p>
            * Type conversion: manual / explicit type coversion.
            * Type coercion: automatic / implicit type conversion by JS.

            * String to number
                Number('15') => 15 (number)
                Number('Protick') => NaN (Not a number)

                *** typeof NaN === 'number'     [Confusion 2]
            
            * Number to string 
                String(25) => '25' (string)
            
            * Coercion: 
                +           -> coerce number to string if any of the operand is string and others are numbers. 
                / , * , -   -> coerce string to number

            * Boolean conversion 
                Boolean(0)  -> false
                Boolean({}) -> true // [Confusion 3]
            
        </p>


        <h2>Truthy, Falsy and Nullish values</h2>
        <p>
            Falsy values 
                1. 0            (zero)
                2. ""           (empty string)
                3. undefined    (undefined)
                4. NaN          (Not a Number, returned after string to Number conversion)
                5. null         (null)
            
            Truthy values 
                everything else is truthy value. 

            Nullish values
                1. null
                2. undefined 

                * zero, empty strings are not nullish values  
            
        </p>


        <h2>Short circuitting and logical assignment operators</h2>
        <p>
            operators used to short circuit the evaluation of an expression:

                Logical operators || and && can take any data typed value as operand and return 
                resultant value of any data type by short circuitting the rest of the evaluation of an expression. 
            
            * || ('logical or' operator): 
                if first operand is a truthy value then returns the first operand and short circuits the rest of the 
                evaluation or if all the operands are falsy then returns the last operand 

                * fails if the operand is 0 (zero), to solve this problem we have another operator - ??

            * ?? ('nullish coalescing' operator): 
                same as 'logical or' || , but works with the idea of nullish values instead of falsy values. 
                counts 0 or "" strings as truthy values as well, becaues they are not nullish

            * && (logical and operator):
                returns the first falsy operand it encounters while evaluating an expression or if 
                all operands are truthy then returns the last operand. 

            * Use cases of short circuitting 
                1. || (or) for setting default values to variable. 

                    let abc = Number(prompt('enter a number')) || 1; 

                2. && (and) for conditional statement execution 
                    abc ?? console.log(abc);

            * Logical assignment operators (ES2021)
                1. rest2.numGuests ||= 10;
                2. rest2.numGuests &&= 10;
                3. rest2.numGuests ??= 10;
            
        </p>


        <h2>Control structure</h2>
        <p>
            * if ( condition ){
                    statements; 
                } else {
                    statements;
                }
            
            * switch( var ) {

                case val1:
                case val2: 
                    statement;
                    break;

                default: 
                    statement;
                }

            * ternary / conditional operator 
                condition ? execute if true : execute if false;

                ternary operator can also be used with template literals or where a experssion or value is expected.
                In template literals you can not use if else condition because they are statements

            * Error handling 
                try{
                    // code where an exception might happen.

                }catch(err){
                    console.log(err.message);

                } finally {
                    // always executes after try or catch block. 
                }
            
        </p>    


        <h2>Loops</h2>
        <p>
            * for

                for ( let i = 0; i < arr.length; i++ ) {
                    statements;
                    continue; 
                    break;
                }


            * while 
            
                let counter = 1; 
                while (counter < 10) {
                    statements;
                    continue;
                    break;
                    counter++; 
                }
                

            * for of 

                const num = [ 10, 20, 30];
                for( item of num ){
                    statements; 
                    continue;
                    break;
                }
            
        </p>
        

        <h2>Function</h2>
        <p>
            * function declaration 

                funcName(1, 2); 
                // you can invoke function that uses declaration syntax prior to declaring the function
                // because of 'hoisting' 

                function funcName(parameter1, parameter2){
                    console.log(parameter1);
                    return parameter1 * parameter2;
                }

            * function expression 
                you can not invoke function expression before declaring them, arrow function is also a kind of 
                function expression or anonymous function, 
                
                * Anonymous function ( Function Expression )
                    const funcName = function (param1){
                        return param1 + 1;
                    };

                * Arrow function 
                    * const funcName = param1 => param1 + 1; 
                    // single parameter does not require parenthesis () 
                    // and single statement doesnt require braces {} around them

                    * const funcOther = (param1, param2) => {
                        console.log(param1);
                        return param1 * param2;
                    };

            * JS function parameter does not need let or const during declaration because whether we use them or not 
                the parameter's scope always confined within the function body. 
            
            * move line up by alt + ^ 

            * Regular functions v/s arrow functions
                *** Execution Context for arrow function do not get "arguments" objet and "this" keyword.

            * Spread operator: 
                const arr = [10, 20, 30];

                newFun(...arr); // is similer to, 
                newFun( 10, 20, 30 );

            * Rest Pattern 
                const newFun = function ( ...args ){
                    // args == [ 10, 20, 30 ]
                }
                    // can take indefinite number of arguments with rest parameter 


            * Default parameter 
                parameter that are not mandatory to invoke the function / method 

                    function foo(name, age=25, numOfPass=1, price=numOfPass * 199){
                        //function body
                    }

                    // here in function 'foo' parameter 'age' is optional, 
                    // if not provided during function call it will be automatically set to 25 

                    // an expression that includes other parameters can be set as a value to another parameter too
                    // provided that the parameter used in the expression is defined earlier in the parameter list.
                    // parameter definition order is counted from left to right
            
            * Passing arguments (Value V/S Reference)
                JavaScript is never pass by referece, we might pass referece of an object to a function but 
                not pass by reference.

                1. changing a primitive variable's value by a parameter does not change the value of the argument. 
                2. changing a passed object's property by accessing the parameter also changes the value of that 
                    property in the passed argument. 
                

            * First class function 
                1. JavaScript treats functions as first-class citizens that means functions are simpy values and 
                    it is a language feature. 

                2. Functions are just another type of object. 

            * Higher order function 
                Functions that receives or ( and ) returns a function are called higher order function. 
                This is possible because JavaScript treats functions as first-class citizens (values).

            * Function property 
                functions can even have properties such as 'name' property of a function returns it's name 
                
            * Example of Higher order functions 
                    document.element.addEventListener('event', function callMeBack ( ev ){ });
                
                here 'addEventListener' is a Higher Order function as it takes 'callMeBack' callback function as a 
                parameter. 
                In this specific case, 'callMeBack' callback function is called 'event listener' or 'event handler'
                function. 

            * what are the benefits of callback function ?
                1. Callback functions allow us to create abstraction
                2. Makes it easy to split up our code into more reusable and interconnected parts. 
                
                * What is 'Abstraction' ? 
                    Abstraction - Hide the detail of some code or implementation details because we dont really care 
                                    about all that details, this allow us to think about problems at a higher or 
                                    more abstract level.

                                    
            * Function can return other function in JavaScript and it works because of 'Closure' and this kind of 
                practice is used in functional programming. 


                const obj = {
                    name: 'Protick Roy', 
                    printGreetName: function (greetings){
                        console.log(`${greetings} ${this.name}`);
                    }
                }

                const obj2 = {
                    name: 'John Doe', 
                    printGreetName: function (greetings){
                        console.log(`${greetings} ${this.name}`);
                    }
                }

            * call()
                1. The call() method calls a function with a given 'this' value and arguments provided individually.
                2. The call() allows for a function/method belonging to one object to be assigned and called for 
                    a different object.

                        const printGreetName = obj.printGreetName; 
                        printGreetName.call(obj2, 'Hello');

                    * immediately invokes the function that has been set to a new 'this' value with call() method. 


            * apply()
                1. calls a function with a given 'this' value, and arguments provided as an array 
                    (or an array-like object).
                2. allows for a function/method belonging to one object to be assigned and called for 
                    a different object.

                        const printGreetName = obj.printGreetName; 
                        printGreetName.apply(obj2, ['Hi']);

                    * immediately invokes the function that has been set to a new this value with apply() method. 


            * bind() 
                1. The bind() method creates a new function that, when called, has its this keyword set to the 
                    provided value, with a given sequence of arguments preceding any provided when the new function 
                    is called.
                2. bind() - binds parameters beforehand and returns a new function with predefined parameters 

                    const printGreetName = obj.printGreetName; 
                    const newFunc = printGreetName.bind(obj2, 'Hello');
                    newFunc();

                * pre-defining function parameters is also called 'partial application'

                * partial application without 'this':
                    func.bind(null, arg1); 
                    func();

            * For call(), apply() and bind() the first parameter has to be an object's reference or null


            * IIFE - pattern 
                Immediately Invoked Function Expression - is a pattern invented by some devoloper which is used to 
                create a function that will be called only once and the main purpose of this was to encapsulate data 
                within a scope which can not be accessed by any other code out of this scope. 

                    (function (){ console.log('will run once')})();
                    ( () => console.log('will run once') )();

                * It is a pattern not a language feature, the same effect can be obtained by 
                    modern scoped variable i.e., 
                        {
                            let val1 = 10; 
                            const val2 = 20;
                        };

            * Closure 
                Any function always has access to the variable environment of the execution context 
                in which the function was created even after the parent execution context is popped off the 
                call stack.

                    1. VE attached to the funciton, exactly as it was at the time and place the function was created
                    2. Inner function closes over it's parent's scope. Even if the execution context is destroyed, the 
                        VE attached to that EC survived including the parent's parameters and accessible within the 
                        child / inner function. 

                    this closing action or the relationship to the parent's variable environment is called 'Closure'

                    * variable lookup first starts with the closure of a function if there is a global variable with 
                        the same name it will be replaced by closure's variables. 

                    * console.dir(function); // logs closures and scope chain
                        => [[internal property we can not access]]

            * it is a common practice to put everything of a component in a function and then call it 
                you can also pass an object to it as an argument list to initialize the component 
            
        </p>


        <h2>Array</h2>
        <p>
            * const numbers = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]; // literal syntax
            * const numbers = new Array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
            
            * numbers.length -> 10
            * we can access and mutate array values by index as, 
                numbers[0] == 1
                numbers[4] = 100;

            * Array can contain elements of different data types and also other arrays, objects. 

            * Array methods
                1. numbers.push(11, 12, 13, 14); // adds elements (11, 12, 13, 14) at the end of the array 
                                                 // ( 'numbers' in this case)
                                                 // returns new length of the array 
                                                 
                2. numbers.unshift(0);  // adds elements in the beginning and returns new length
                3. array.pop();         // returns last element that is popped of the array 
                4. array.shift();       // removes and return first element from the array 
                5. numbers.indexOf(10)  // returns index of the element or -1 if not found
                6. numbers.includes(7)  // return true if element exists or false if not

                7. arr.entries()        // returns an iterator, where each iteration returns an array 
                                        // like [index, value];
                                        // if it returned an array instead of an iterator it would be like this, 
                                        // [ [index1, value1], [index2, value2] ... [indexN, valueN] ] 


            * Destructuring
                unpacking array elements to seperate variables. 

                const arr = [10, 20, 30];

                1. const [var1, , var3 ] = arr; 
                    // var1 == 10, var3 == 30; 
                    // we omitted the 2nd value of the array by placing a hole in the destructuring operation. 

                2. destructuring and default values 
                    const [var1, var2, var3, var4 = 100] = arr;
                    // var4 == 100
                    
                3. nested destructuring 
                    const [var1, var2, [ var3, var4]] = [ 1, 2, [10, 20]];
                    // var1 == 1, var2 == 2, var3 == 10, var4 == 20

            
            * Rest pattern 
                const [item, ...others] = [ 1, 2, 3 ];
                // item == 1, others == [ 2, 3 ]

                * Rest element must be the last element of an expression. 
                * There can be only one rest element in one destructuring statement

            * Spread Operator 
                1. const numbersArr = [ ...arr ];       // spreads the 'arr' array to 10, 20, 30
                2. const newArr = [ 100, 200, ...arr ]; // newArr == [ 100, 200, 10, 20, 30 ]

                * if we need array elements seperated by comma we use spread operator.
                * spread operator works on all iterables such as, array, string, map, set


            * Array methods extended
                let arr = ['a', 'b', 'c', 'd', 'e'];
     
                SLICE
                    console.log(arr.slice(2));
                    console.log(arr.slice(1, -2));
                    
                    // create a shallow copy of arr 
                    console.log(arr.slice());
                    console.log([...arr]);
                    
                
                SPLICE 
                    // almost same as slice() but with one exception that splice() mutates the original array
                    
                    console.log(arr.splice(2));
                    console.log(arr);
                    
                    // generally what is returned by the splice() method does not interest us rather we use splice often to delete
                    // element from an array 
                    // one most common use case is to delete the last element of an array 

                    console.log(arr.splice(-1));
                    console.log(arr);

                
                REVERSE
                    const arr2 = ['j', 'i', 'h', 'g', 'f'];
                    console.log(arr2.reverse());
                    // console.log(arr2);
                
                CONCAT
                    let letters = arr.concat(arr2);
                    console.log(letters);
                    console.log([...arr, ...arr2]);
                
                JOIN                
                    console.log(letters.join('-'));
                    // returns a string and does not mutate the original array 

                The new at() method (ES2022)
                    arr.at(0)   // returns the first element
                    arr[0]      // also returns the first element

                    1. to get the last element
                        arr.slice(-1)[0];
                        arr[arr.length -1];
                        
                        or simply, 
                        arr.at(-1); 

                    2. another use case of at() method is 
                        method chaining 
                    
                    3. at() method also works on string                
        </p>


        <h2>Set</h2>
        <p>
            collection of unique elements with no duplicate elements in them 

                const orderSet = new Set( ['pasta', 'pizza', 'risotto', 'pizza', 'pasta'] );
                    // orderset = { 'pasta', 'pizza', 'risotto' }

                    // typeof orderSet == object //tested

                const nameChar = new Set('Protick');

            * set can have mix data type elements 
            * sets are also iterables and order of element is irrelevant 
            * sets take an iterable as constructor argument. 

            * Set methods
                1. orderSet.size                // returns size/length/number of elements of the set
                2. orderSet.has('pasta')        // returns true or false if element exists in the set or not 

                3. orderSet.add('Garlic Bread') // adds new element to the set, but do not add duplicate entry: 
                                                // and returns updated Set object
                                                // only takes 1 argumnet per call

                4. orderSet.delete('Pasta')     // deletes element 'Pasta' from set 'orderSet' 
                                                // if it exists and returns true or false 
                                                // if the provided element to be deleted does not exist in the Set. 

                5. orderSet.keys()              // return a new Set iterator, alias for orderSet.values();
                6. orderSet.values()            // return values, a new Set iterator

                7. orderSet.entries()           // returns a new Set iterator in this, 
                                                // { 'element' => 'element', 'elem' => 'elem' } format. 

                8. orderSet.clear()             // deletes all elements from set. 

            * you can not retrieve a specific value from set using an index, it is an iterable so loop over it or 
                use has() to check if it contains a specific values, which is its main application other than maintai-
                ning uniqueness of elements.  
            
        </p>


        <h2>Map</h2>
        <p>
            * actually array of arrays which contains [ key, value ] pairs but it is a Map object 
                Map object is different from generic objects as 
                1. Map can have key/property which need not to be strings only.
                2. Map has built in methods like has(), delete() etc. which will not work on generic objects 
            
            * How to create Map
                1. const restMap = new Map();
                2. let nm = new Map(iterable);
                    e.g.,
                    const restMap = new Map([
                        [1, 'one'],
                        [2, 'two'],
                        [3, 'three'],
                    ]); 

                * you can make a Map object out of a 2D array which contains [key, value] pairs. 
                    let arr = [ ['key1', 'value1'], ['key2', 'value2'] ];
                    const newMap  = new Map(arr);

                * create a map from an object 
                    const newMap = new Map(Object.entries(obj));
                        // beacause Object.entries(obj) === [ ['key1', 'value1'], ['key2', 'value2'] ]

                * convert Map to an Array 
                    const keys = [ ...restMap.keys() ];         // array of Map keys 
                    const values = [ ...restMap.values() ];     // array of Map values
                    const mapToArr = [ ...restmap ];            // convert entire map to an array

                    // you have to use the spread operator because 
                    // Map.keys() , Map.values() and Map.entries() returns an iterator not an array or elements

                * typeof restMap == object 



            // JS wont stop you from doing this, but this is a map object used like a generic object 
            // Array, Map, Set all are kind of an object after all. 

                const wrongMap = new Map()
                wrongMap['bla'] = 'blaa'
                wrongMap['bla2'] = 'blaaa2'
                
                console.log(wrongMap)  // Map { bla: 'blaa', bla2: 'blaaa2' }
            //

            * Map can have mix data type values and keys 
            * Map are also iterables and order of element is preserved
            * Map take an iterable as constructor argument or no argument at all. 
            * keys are case sensitive and key type matters, '1' !== 1 

            * Map methods
                1. restMap.size                 // returns size/length/number of elements in the Map
                2. restMap.has('2')             // returns true or false if element exists in the Map whose key is '2'

                3. restMap.set('1', 'pizza')    // adds new element to the Map, but do not add duplicate entry: 
                                                // only takes 1 key value pair per call
                                                // returns updated Map Object and 
                                                // we can chanin multiple set().set() methods to insert multiple 
                                                // entries at once. 

                4. restMap.get(1)               // get element from Map 'restMap' whose key is 1;  or undefined 
                                                // if not found

                4. restMap.delete('Pasta')      // deletes element from Map 'restMap' whose key is 'Pasta'
                5. restMap.keys()               // returns a new Map iterator with only keys in it. 
                6. restMap.values()             // returns a new Map iterator with only values in it. 
                7. restMap.entries()            // returns a new Map iterator with { key => value } pairs
                8. restMap.clear()              // deletes all key value pairs from restMap.

            * We can set object and arrays as key to a map but you will need the same object / array 
                referece to get the value at that key

            * Map from generic object 

            * Map is itarable
                for ( const [key, value] of restMap ){ console.log(key, value); }
        
        </p>


        <h2>Built In Higher Order functions for Iterables</h2>
        <p>
            * forEach()

                // Array 
                    let arr = [ 10, 20, 30 ];
                    arr.forEach( function (item, index, wholeCollection) {
                        console.log(index, item);
                    } );
                
                // Map 
                    const currencies = new Map([
                        ['USD', 'United States dollar'],
                        ['EUR', 'Euro'],
                        ['GBP', 'Pound sterling'],
                    ]);

                    currencies.forEach(function (value, key, wholeCollection){
                        console.log(key, value);
                    });

                // Set 
                    const currencies = new Set(['USD', 'EUR', 'GBP', 'USD', 'EUR']);
                    currencies.forEach(function (value, _, wholeCollection){
                        console.log(value);
                    });
                        // because Set does not have key or index
                        // as per standard convention throwaway variables are declared with only single underscore, _
                    
                you can not 'break' out or 'continue' like 'for of' or other type of loops from forEach()


            * map()
                const movementsUsd = account1.movements.map((movement, i, arr)=> Math.trunc(Math.abs(movement * 1.1)));
                console.log(movementsUsd);

                * One really important distinction between forEach() and map() is if you want to create and return a 
                    new array then use map() or if you want to perform a certain action while looping through an array
                    use forEach()

            
            * filter() 
                return a new array based on boolean value returned by the callback function, 
                1. if the returned boolean value is true then the current element stays in the new array 
                2. if the returned boolean value is false then the current element is not included in the new array 

                    const deposits = account1.movements.filter(
                        (movement, index, arr) => movement > 0
                    );
                    console.log(deposits);

                    
            * reduce() 
                reduces or boils down the whole array into a single value, 

                    const min = arr.reduce(function (accumulator, currentItem, index, wholeCollection){
                        return accumulator <= currentItem ? accumulator: currentItem; 
                    }, arr[0]);

                    const sum = arr.reduce(function (sum, item, i, arr){
                        return sum += item;
                    }, arr[0]);
            
            * chaining methods 
                const interest = movements
                    .filter(mov => mov > 0)
                    .map(mov => (mov * 1.2) / 100)
                    .filter(intrst => intrst >= 1)
                    .reduce((acc, intrst) => acc + intrst, 0);

                1. Do not over use it 
                2. Do not use any methods in the chain that mutates the original array such as reverse() and splice()


            const arr = [1,2,3,4,-1,-2,-3];
            * find() 
                const account = accounts.find((ac, i, wholeCollection) => ac.owner === 'Jessica Davis');
                console.log(account);
                    // returns the 'first matched' 'element' from an array
                    // often returns object from an array of objects based on condition
                    // unlike filter it does not return an array of elements 

                    let res = arr.find((item, index, arr) => item >=3 );            
                    console.log(res) === 3               

            * findIndex( (item, i , wholeCollection) => return item > 100);
                // return index of an item from an array based ono codition in the callBack function
                res = arr.findIndex((item, i, arr) => item >= 3);
                console.log(res) === 2
    
            * some() 
                    similer to arr.include(1); // but check is based on equality if any array elements === 1

                    // returns true or false based on codition in callback function
                    // based on any type condition
                    let res = arr.some((item, i, arr) => item < 0);
                    console.log(res) === true
            
            * every() 
                // check if all elements satisfies condition and returns true or false
                    let res = arr.every((item, i, arr) => typeof item === 'number');
                    console.log(res) === true

            * you can write the callback function seperately and pass the function as callback to any methods that 
                expects a callback

            * flat() 
                flattens a nested array to array of single elements 
                    let arr = [ [1, 2], 3, 4, 5, [6, 7, 8] ];
                    arr = arr.flat(); // default depth level is 1 

                you can flatten arrays nested more than 1 level by
                    arr.flat(2);

            * flatMap(mapping condition)
                map() and then flat() the resultant array is fairly common acction you can simpley this process of 
                calling map and then flat() by flatMap() method 
                
                NOTE: flatMap() can go only 1 level deep so if you need to go more than 1 level deep you need to use 
                flat() method anyway. 

            * Built in JavaScript sort methods 
                * sort()
                    let arr = ['Protick', 'Sajib', 'Apu', 'Mahbub', 'Ahnaf'];
                    arr.sort(); 
                    arr === ['Ahnaf', 'Apu', 'Mahbub', 'Protick', 'Sajib']
                        // mutates the original array   

                    let arr = [1,2,3,4,-1,0,-2];
                    arr.sor();
                    arr === [-1, -2, 0, 1, 2, 3, 4]
                        // sort() method works based on string so 
                        // numbers are converted to string then sorts 
                        // that is why first element is -1 not -2 
                        // we can fix this by passing a callback function

                    arr.sort(function (curr, next){ 
                        // parameter order does not matters curr and next parameters can hold either first or second element 
                        // interchangably based on array data 

                        // return == 0 does not swap //tested in V8 
                        // return < 0 swaps , curr next => next curr
                        return next < curr ? -1 : 1;
                    });

                    lets optimize, 
                    arr.sort((curr, next) =>  curr - next); // if next > curr then next - curr = -n => swap => curr next
                                                            // array sorted in ascending order
                    arr.sort((curr, next) => next - curr); // array sorted in descending order 

                    thats all for now, sort() is messed up if you think about how it works
                    Explain me this example, 
                        let arr = [-4, -1, -2, -3].sort((curr, next) => next - curr); // descending order -1 -(-4) => 3
                            // arr === [-1, -2, -3, -4]

                    let arr = [-4, -1, -2, -3];
                    arr.sort((curr, next) => { 
                            console.log(`Current: ${curr}, Next: ${next} `); 
                            console.log(`res: ${next - curr}`); 
                            return next-curr 
                        });

                    console.log(arr);

                    * Also two parameters that sort function have can receive objects if the array 
                        is an array of objects
                    [Confusion 4]
                
                * Generate Arrays programmatically 
                    * Array of empty elements 
                        let x = new Array(7);  ==== [ empty x 7 ] // array of 7 empty elements 
                        * no methods can be called on array of empty elements other than the 'fill()' method.
                        
                        * x.fill(value, startIndex, endIndex);                 
                            // mutates the original array 

                    * from()
                        Array.from({length: 7}, callbackThatActsLikeMap(item, i, arr){ return i + 1; });
                        // returns a new array === [ 1, 2, 3, 4, 5, 6, 7 ]; 

                        * was intially introduced to create array from array like structures, such as, strings, 
                            maps, sets and iterables

                        * use case 
                            let valuesFromDom = Array.from( document.querySelectorAll('.movements__value'), 
                                                            (elem) => elem.textContent.replace('€', '') );

                            1. gather data from dom and put in an array 
                            2. covert node list to an array of values 

                            you can also covert DOM node list to an array by, 
                                [ ...document.querySelector('.query') ];
                                
                *** Be comfortable with filter() method and also remember filter() method creates new array based on 
                        original array and condition defined in callBack function 

                    * also callBack function can be defined else where and passed to these array methods which expects
                        a callback functions; but remember to match the arguments and parameters as we dont call them 
                        but the higher order array methods
        </p>        


        <h2>Object</h2>
        <p>
            * Objects are self-contained pieces/blocks of code that are considered as building block of an application 
                and objects interact with each other through public interfaces called API methods. 

            * object declaration
                const obj = {
                    firstName: 'Protick', 
                    lastName: 'Roy', 
                    age: 2022 - 1994, 
                    friends: [ 'one', 'two', 'three' ],
                };
                // this is called object literal syntax 

                 let obj = new Object(); // obj of generic Object class

            * accessing object properties by . (dot) and [] (bracket) notation
                obj.firstName => 'Protick'
                obj['lastName'] => 'Roy' 
                // notice the quoation mark around the property name, single and double quotes both are permitted

            * object property accessor . (dot) => associativity left to right

            * Adding new property to object by . and []
                obj.country = 'Bangladesh';
                obj["profession"] = 'Software Developer';

            * Object method
                function declaration inside an object does not work so we need to store the function (expression) in a 
                property.

                const obj: {
                    getAge: function returnAge(){ 
                        // function name returnAge is unnecessary here, we can omit it like the following function
                        return this.age;
                    }, 

                    getFirstName: function (){
                        return this.firstName;
                    },

                    printStr: (str) => console.log(str), 

                    // but the following wont work 
                    function howDoYouCallMe(){
                        console.log('because I am inside an object but do not belong to any property'):
                    }
                };
            
            * Object literal's braces do not mark a block scope. 
            * If a property is not available in an object it is simply undefined. 
            
            *** if an object method defines a ragular function or function expression within itself and invokes the 
                newly created inner function, it is considered regular function call so 'this' is set to undefined 
                for the inner function. 
                    1. You can use arrow function as arrow function's 'this' is set to 'parent's this'
                    2. or you can set a local variable to 'this' and use that local variable within the inner function.
                    
            * Object.assign({}, srcObj); 
                => creates a shallow copy of srcObj and  returns a new object; merges srcObj with empty object;
                => To make a deep copy of an object we use third party libraries like lodash 
                        
            * Method borrowing
                objNew.newProperty = oldObj.method;  
                    // now objNew has oldObj.method in it. 

            * Primitives vs Objects 
                * primitive type 
                    Number, String, Boolean, Undefined, Null, Symbol, BigInt 
                    stored in Execution Context and EC is placed in the callstack 

                * Object 
                    object literal, Arrays, Functions 
                    stored in HEAP

                * variable stores memory address. 
                    1. changing value of a primitive type variable changes the memory address to a new location
                        where new value is stored. 
                        
                    2. Primitive type variable stores memory address where actual value is stored. 
                    
                    3. Reference type variable stores memory address which in turn stores memory addres of the object 
                        in the HEAP. Because object is too big to store in call stack. 
                        so copying a object to another variable shares the same memory address from the HEAP. 
                        which leads to unwanted property value modification.

            * Destructuring Objects 
                As object properties do not retain the order in which they are placed in the object literal we need to 
                specify the object's specific property name to destructure it. 

                let firstName = "John"; 
                let lastName = "Doe";

                const obj = {
                    firstName: 'Protick', 
                    lastName: 'Roy', 
                    age: 2022 - 1994, 
                    friends: [ 'one', 'two', 'three' ],
                    likes: {
                        'weather': 'rainy', 
                        'day': 'shiny'
                    }
                };

                const { firstName:fn = 'John', lastName:ln = 'Doe', likes:{ weather:w, day:d } } = obj;

                // 'firstName' => object property 
                // 'fn' => new variable that holds the value of obj.firstName; 
                // fn = 'John' => default value 'John' 
                // w and d destructuring nested obj 'likes'
                
                * mutating pre defined variables while destructuring, 
                    ({firstName, lastName} = obj);

                * Use cases of object destructuring are many but one specific use case can be, 
                    object as argumend and destructure the object parameter to unpack arguments. 

            * Spread operator
                since ES2021 spread operator is also usable with objects, though they are not iterables
                we can use spread operator to make a shallow copy of an object. 

            * Enhanced Object Literals 
                1. Including variable in an object with the same property name as the variable can be done as, 

                    const newVar = 10;
                    const obj = {
                        newVar, // same as newVar: newVar, 
                    };

                2. Adding method to an object without function keyword and property name, 
                    
                    const obj = {
                        printStat ( param1 ){
                            console.log(param1);
                        }
                    };

                3. Computed property name, 

                    const obj = {

                        // third brackets are a must to compute a property name. 
                        [ `day-${ 4 + 5}` ]: { 

                            //nested object
                        }, 
                    };
            
            * Optional chaining (ES2020) 
                '?' operator 

                1. if property exists
                    restaurant.openingHours.mon?.open
                    if 'mon' property exists on 'restaurant.openingHours' then perform restaurant.openingHours.mon.open
                    if it does not then return undefined. 

                2. we can use optional chaining operator with nullish coalescing operator to check if, 
                    a) Method exists, 
                        const res = obj.method?.() ?? 'method does not exist or returned nullish value';
                        
                    b) array exists or empty 


            * Looping Objects 
                1. Object property names are also called keys
                    Object.keys(obj); 
                        // returns array of properties of obj 
                
                2. Object property values
                    Object.values(obj); 
                        // return array of values of obj 

                3. Object keys and values 
                    Object.entries(obj); 
                        // objects are not iterable so we use this method to make it iterable
                        // returns [ [key1, value1], [key2, value2] ... [keyN, valueN] ] ; 
                        // an actual array unlike array.entries() which returns an iterator object;
            
        </p>


        <h2>Object Oriented Programming in JavaScript</h2>
        <p>
            * OOP principles
                1. Abstraction 

                    input ---------------> black box -------------> output.
                                         (abstraction)             

                    * hiding implementation details 
                        e.g., we do not need to know about how engine works to ride a motorcycle.

                2. Encapsulation 
                    encapsulating properties and behaviors that need not to be accessed to use the class and confine
                    those private properties and behavior's access within the class itself.

                        e.g., 
                        we do not need to interact with the engine's piston and sylinder itself to ride a 
                        motorcycle but we are given access to its intake (Public Interface API) capacity
                        through the accelerator and we receive the resultant output as roation of wheels which 
                        translates to movement of the vehicle

                        On the other hand the crank shaft might interact with the piston itself via the connecting rod. 
                        Consider the whole engine as a 'Class' and accelerator, clutch as 'Public Interface API' to 
                        that 'Engine Class'
                    
                3. Inheritance 
                    Children inherits their parent's properties and behaviors 
                        e.g., 
                        You inherited your parent's properties such as house, cattles, skin color, height 
                        You inherited your parent's behaviors such as both your parent and you are lactose intolerant. 
                        
                4. Polymorphism 

                    If you think about the Greek roots of the term, it should become obvious.
                        Poly = many: polygon = many-sided, polystyrene = many styrenes (a), polyglot = many languages
                        Morph = change or form: morphology = study of biological form, 
                        Morpheus = the Greek god of dreams able to take any form.

                    Polymorphism describes a pattern in object oriented programming in which classes have different
                    functionality while sharing a common interface.
                    
                    Children overrides their parent's behaviors
                        e.g., 
                        Your parent's behavior such as your parents were 'farmer' and you inherited that 
                        but overwrote it with 'programmer'

                        Note: function overloading is also considered polymorphic behavior. 

                    
                    code example C#,                     
                        public abstract class Vehicle{
                            public abstract int Wheels;
                        }

                        public class Bicycle : Vehicle{
                            public override int Wheels(){
                                return 2;
                            }
                        }

                        public class Car : Vehicle{
                            public override int Wheels(){
                                return 4;
                            }
                        }

                        public class Truck : Vehicle{
                            public override int Wheels(){
                                return 18;
                            }
                        }

                        public void Main(){
                            List<Vehicle> vehicles = new List<Vehicle>();

                            vehicles.Add(new Bicycle());
                            vehicles.Add(new Car());
                            vehicles.Add(new Truck());

                            foreach (Vehicle v in vehicles)
                            {
                                Console.WriteLine(
                                    string.Format("A {0} has {1} wheels.",
                                        v.GetType().Name, v.Wheels));
                            }
                        }

            * Purpose Of OOP 
                OOP was developed to make application programming more flexible and easier to maintian
            
            * How JavaScript implements OOP ?
                In OOP supported standard languages such as Java, C++ OOP is implemented as, 

                    Class   ------------------------->  Instance
                Blueprint   ----( Instantiation )---->  Object

                In JavaScript, 
                    Objects are linked to a prototype object or we say each object has a prototype. 
                    Prototypes has methods and properties and all the object that are linked to a prototype 
                    can access properties and methods of that prototype object. 

                Prototypal Inheritance: 
                    This model of inheriting property and methods from prototype is called prototypal inheritance.

                    It is different than 'class inheritance' 
                    As oppose to inheriting parent's methods/behaviors in the child class 
                    In prototypal inheritance object just delegates behaviors to linked prototype object.
                    This model of OOP implementation is also called 'delegation'
                    
                    Example, 

                        Array.prototype.map() 
                        when we create an array in JavaScript the array object has a prototype called 'Array.prototype'. 
                        In other words, the newly created array object is linked to a prototype object 'Array.prototype'
                        
                        which in practice allows the new array object to access its prototype objects's methods 
                        which are defined in that prototype object - "Array.prototype" . 
                        
                        In practice that action/mechanism translates to, 
                        1. Our array object inherits the map() method from 'Array.prototype'
                        2. Our array object delegates the behavior of map() to its linked object 'Array.prototype'.


                * 3 ways to implement Prototypal Inheritance, 
                    1. Constructor function: 
                        are way of creating objects programmatically using a function which will also set new object's 
                        prototype. This is how built-in object like Array, Map, Set are implemented. Also this is how 
                        OOP has been done in JavaScript since the beginning. 

                    2. ES6 Class: 
                        Modern way of doing OOP in JavaScript. These are not the kind of classes that are traditional 
                        or how we use Classes in other languages. Instead they are syntatic sugar over constructor 
                        functions. Behind the scene ES6 classes are implemented with constructor function and so 
                        they also use prototypal inheritance. 

                    3. Object.create(): 
                        The easiest and most straight forward way of linking an object to a prototype. It is not as 
                        used as other two methods. 
                    
                    *** 4 Principles of OOP are still valid for 'Protypal Inheritance'

            * Implementing OOP with Constructor Function 

                * 'new'
                    const Person = function (firstName, birthYear) {
                        this.firstName = firstName; 
                        this.birthYear = birthYear;
                    };

                    // static method
                    Person.hey = function () {
                        console.log(`Static method / helper function`);
                        // this === constructor function
                    };

                    // instance method
                    Person.prototype.calcAge = function () {
                        return new Date().getFullYear() - this.birthYear;
                    };

                    const protick = new Person('Protick', 1994);
                    console.log(protick instanceOf Person); === true;
                    Person.hey();

                    *  It is a convention that constructor function name should start with Capital letter 

                    1. When a function is called with the 'new' keyword: 
                        i)   New empty object '{}' is created 
                        ii)  Then the function is called with its 'this' property set to newly created 'empty object {}'
                        iii) The new 'empty object {}' linked to a prototype. Actually, to constructor function's 
                            'prototype' property which references an empty object
                        iv)  the constructor function automatically returns the newly created object

                    2. function declration inside a constructor function is not a good practice as all objects that 
                        are created using the constructor function will make a copy of that method for its own 
                        instance which will lead to unnecessary duplication of the same code. Instead we should 
                        use 'prototype' in this case.

                * Prototype 
                    1. Each and every function including constructor function in JavaScript has a property 
                        called 'prototype' which generally references an empty object.  

                    2. Object that is created using a constructor function will be linked to that constructor 
                        function's prototype property.

                    3. Linked object will get access to to all the methods and properties that are defined on that 
                        object's prototype 

                    4. Everything in JavaScript is an object and all object have a property called '__proto__' that 
                        links that object to its prototype.

                    So what is a prototype ? 
                        it is a higher level object that gets linked to its child object by the child object's 
                        constructor() function. 

                        'prototype object' can have properties and methods defined on it which will be available to 
                        its linked child object through the prototype chain

                        Methods and properties that are defined on an object's prototype are not the object's own 
                        property or methods, they are just accessible to the linked object. 
                            obj.hasOwnProperty('propertyName') returns true or false. 

                        'prototype' of an object is linked to that object via '__proto__' property

                        for example for the source code above, the newly created 'protick' object's 
                        prototype is 'Person.prototype'
                            protick.__proto__ === 'Person.prototype'

                        so prototype of an object is 'prototype property' of that object's constructor function.
                            Person.prototype.isPrototypeOf(protick) === true


                        * functions are also objects so they also have a prototype that they inherit / links to.
                            prototype of a function is 'Function.prototype'
                                Function.prototype === someFunction.__proto__   // true

                        *   Buy 1       get         1 Extra                        
                            (obj)                   (prototype) 

                        * Extending a prototype of a built-in object with custom properties and 
                            method is not a good idea.

                * Prototype chain 
                    same as scope chain but with prototypes. Prototype of an object is also an object itself so 
                    prototype object also has its own prototype 

                    At top of the prototype chain is always a prototype which is 'Object.prototype' that is 
                    created by the 'Object()' constructor function. 

                    Top prototype object's __proto__ property is set to null.

                    The Object() constructor function is called when we create a new object by object literals, 
                    constructor functions or by ES6 class.

                    Whenever JavaScript can not find a property in certain object its gona lookup into the next 
                    prototype in the prototype chain.

                    All object (and prototype) has a property called 'constructor' which point to the constructor 
                    of that object. 

            * Implementing OOP with ES6 Class 
                There are two types of syntax available for declaring a ES6 Class 

                1. Declarative Syntax // preferred 

                    class Person {
                        constructor(firstName, birthYear) {
                            this.firstName = firstName;
                            this.birthYear = birthYear;
                        }

                        // instance methods 
                        calcAge(currYear) {
                            return currYear - this.birthYear;
                        }

                        // or this syntax is better to extend a prototype of an object 
                        greet() {
                            console.log(`Hello ${this.firstName}`);
                        }

                        // static method
                        static hey(){
                            console.log(`Static method / helper function`);
                            // this === Class on which it is called
                        }
                    }

                    const protick = new Person('Protick', 1994); 
                    protick.greet();
                    console.log(protick.calcAge(2022));
                    Person.hey();

                    // you can also add methods and properties to a object's prototype
                    /*
                        Person.prototype.greet = function () {
                            console.log(`Hello ${this.firstName}`); 
                        };
                    */
                    

                * anything outside the constructor function will be defined on the Class's prototype 
                    property's referenced object, or in other words, on the prototype object which 
                    newly created object's __proto__ property links to.

                * inside a class body we do not need to use function keyword to declare a method because
                    methods will be defined on the prototype of the object and not on the object itself
                    so function's scope is not determined at class defintion. 
                    

                2. Class Expression
                    const Person = class {
                        
                    };

                Note
                    1. Classes are special kind of functions.
                    2. Constructor function of a class must have the name 'constructor'
                    3. Classes are NOT Hoisted, even if they are class declaration. 
                    4. Classes are also First Class Citizen
                    5. Body of a class is always executed in strict mode. 

                * Setters and Getters
                    We call them 'Accessor properties' and all other normal properties are called data properties. 

                    1. In Object Literals 

                        const obj = {
                            owner: 'Protick', 
                            movements: [10, 15, 19, 300],

                            // getter 
                            get last(){
                                return this.movements.slice(-1).pop();
                            },

                            // setter // needs to have exactly 1 parameter 
                            set last(newMov){
                                this.movements.push(newMov);
                            }
                        };
                        
                        console.log(obj.last);
                        // though last() is a method we can access it as a property and the method returns the value

                        obj.last = 400;
                        console.log(obj.movements); 
                    
                    2. In ES6 Classes 

                        class Person {
                            constructor(fullName, birthYear) {
                                this.fullName = fullName;
                                this.birthYear = birthYear;
                            }
                        
                            calcAge(currYear) {
                                return currYear - this.birthYear;
                            }
                        
                            get age() {
                                return new Date().getFullYear() - this.birthYear;
                            }
                        
                            // setters often used as data validator while creating an object
                            set fullName(name) {

                                // this is a standard practice to use _propertyName to set validated 
                                // data to property when a
                                // property with the same name 'propertyName' exists already

                                if (name.includes(' ')) this._fullName = name;
                                else console.log('Provide your Full name');
                            }

                            get fullName() {
                                return this._fullName;
                            }
                        }
                        
                        const protick = new Person('Protick Roy', 1994); 
                        
                        console.log(protick.calcAge(2022)); 
                        console.log(protick.age);
                        console.log(protick.fullName);
                
                * static methods 
                    Defined in a class's namespace or attached to a constructor function 
                    Related helper function to that class or constructor function which will not be inherited 
                    or accessible to child object via object reference as we access instance methods. 
            

                    
            * Implementing Prototypal Inheritance using 'Object.create()'

                we can set the prototype manually of an object. 
                Object.create() - creates a new object and sets it __proto__ property to specified prototype 
                and returns that empty object
                
                // object literal that will be prototype for Person 
                const PersonProto = {
                    calcAge() {
                        return new Date().getFullYear() - this.birthYear;
                    },
                    
                    init(firstName, birthYear){
                        this.firstName = firstName; 
                        this.birthYear = birthYear;
                    }
                };

                const protick = Object.create(PersonProto);
                // initializing 
                protick.init('Protick', 1994);
                console.log(protick.calcAge()); 
            



            * Inheritance between Classes: 
                1. Using Constructor Function

                const Person = function (firstName, birthYear) {
                    this.firstName = firstName; 
                    this.birthYear = birthYear;
                };
                
                Person.prototype.calcAge = function (){
                    return new Date().getFullYear() - this.birthYear;
                };
                
                const Student = function (firstName, birthYear, course) {
                    Person.call(this, firstName, birthYear);
                    this.course = course;
                };
                
                /* 
                    to make student inherit person we need to manually setup the prototype chain using Object.create();
                    1. basically replacing the empty prototype object of Student() constructor function 
                        with a custom Object which __proto__ is set to Person.prototype

                    2. Or in other words, setting the Student.prototype's prototype to ( Student.prototype.__proto__) 
                        'Person.prototype'
                */

                /* First set prototype chain */
                Student.prototype = Object.create(Person.prototype);
                Student.prototype.constructor = Student; 

                // or this ? instead of above two lines 
                // Student.prototype.__proto__ = Person.prototype; 

                
                /* then add methods */
                Student.prototype.introduce = function () {
                  console.log(` I'm ${this.firstName}, studying ${this.course}`);
                };
                
                const trevor = new Student('Trevor Noah', 1991, 'Computer Science'); 
                console.log(trevor.calcAge());
                trevor.introduce();
                
            *** JavaScript only supports single inheritance



                2. Using ES6 Classes 
                // ------------------ Person -------------------
                class Person {
                    constructor(fullName, birthYear) {
                        this.fullName = fullName;
                        this.birthYear = birthYear;
                    }

                    calcAge(currYear) {
                        return currYear - this.birthYear;
                    }

                    get age() {
                        return new Date().getFullYear() - this.birthYear;
                    }

                    set fullName(name) {
                        if (name.includes(' ')) this._fullName = name;
                        else console.log('Provide your Full name');
                    }

                    get fullName() {
                        return this._fullName;
                    }

                    static hey() {
                        console.log(`Static method / helper function`);
                    }
                }

                // ------------------ Student -------------------
                class Student extends Person {
                    constructor(fullName, birthYear, course) {
                        super(fullName, birthYear);
                        this.course = course;
                    }

                    introduce() {
                        console.log(` I'm ${this.fullName}, studying ${this.course}`);
                    }
                }

                const protick = new Student('Protick Roy', 1994, 'Computer Science');
                console.log(protick.calcAge(2022));
                console.log(protick.age);
                console.log(protick.fullName);
                protick.introduce();
                
                Note: 
                    1. super() - call in the child class's constructor function always needs to happen first because
                        super() is responsible for creating 'this' keyword of the child class. 
                    2. super() is called implicitly if we do not call it explicitely
                    3. we can skip writing a new constructor function for the child class if we do not intend to use 
                        any different initialization parameter other than those defined by the parent class. 
                    4. Overriding/Shadowing parent methods 



                3. Using Object.create()

                const PersonProto = {
                    calcAge() {
                      return new Date().getFullYear() - this.birthYear;
                    },
                  
                    init(firstName, birthYear) {
                      this.firstName = firstName;
                      this.birthYear = birthYear;
                    },
                  };
                  
                  // create a prototype of which prototype is set to PersonProto
                  const StudentProto = Object.create(PersonProto);

                  // now StudentProto prototype inherits PersonProto prototype
                  
                  StudentProto.init = function(firstName, birthYear, course){
                      PersonProto.init.call(this, firstName, birthYear);
                      this.course = course;
                  };
                  
                  StudentProto.introduce = function () {
                      console.log(` I'm ${this.firstName}, studying ${this.course}`);
                  }; 
                  
                  // initializing
                  // create an object which prototype is set to StudentProto
                  const jay = Object.create(StudentProto); 
                  
                  jay.init('Jay Williams', 1994, 'Computer Science');
                  jay.calcAge();
                  jay.introduce();
            
            * another class example 
                * 1. Public field
                * 2. Private field
                * 3. Public method
                * 4. Private method 
                * 5. - 8. (There are also 'static' version of this four types as well)


            class Account {

                // public fields (instance properties not prototype's)
                // 1. Public fields
                locale = navigator.language;

                // private fields (instance properties not prototype's)
                // 2. Private fields 
                #pin;
                #movements = [];

                constructor(owner, currency, pin) {
                    this.owner = owner;
                    this.currency = currency;
                    this.#pin = pin;
                    this.#movements = [];   

                    // Protected property
                    // this._pin = pin;
                    // this._movements = [];
                    // this.locale = navigator.language;
                    
                    console.log(`Thanks for opening an account ${owner}`);
                }

                // APIs / accessor functions
                // Public Interface of our objects
                // 3. Public method
                getMovements() {
                    return this.#movements;
                }

                deposit(value) {
                    this.#movements.push(value);
                    return this;
                }

                // abstraction : that withdraw is a negative movement
                withdraw(value) {
                    this.deposit(value * -1);
                    return this;
                }

                // encapsulatation of protected method: that should not be accessed from
                // outside of the class as per convention
                //
                // _approveLoan(val) {
                //   return true;
                // }

                // 4. Private method 
                // private method defined on the object itself not on the object's prototype's
                //
                #approveLoan(val) {
                    return true;
                }

                requestLoan(val) {
                    if (this.#approveLoan(val)) {
                        this.deposit(val);
                    }
                    return this;
                }
            }

            const accProtick = new Account('Protick Roy', 'BDT', 1234);

            * Method chaining: to be able to do this with our own object we just have to return the object 
            * It make sense to return the current object from a method which sets/changes some 
                property values of the object


        </p>

        <h2>String</h2>
        <p>
            * String is an array of characters 
                const str = "This is a string";

            * strings are primitive values so it is impossible to mutate them 

            * String Methods 

                1. str.indexOf('i'); 
                    // returns 2, position of 'i' in the string 'str'
                    // return first occurance position or -1 if no match found

                2. str.lastIndexOf('i'); 
                    // returns 13, position of 'i' in the string 'str'
                    // return last occurance position or -1 if no match found

                3. str.slice(5);
                    // slice the string starting at position 5 (inclusive) and return the resultant string 
                    // from position 5 to the end; returns a new string => "is a string"

                    * extract the first word 
                        let firstWord = str.slice( 0, str.indexOf(' ') );
                            // returns a new string => "This"

                    * extract the last word 
                        let lastWord = str.slice(str.lastIndexOf(' ') + 1 );
                            // returns a new string => "string"

                    * start slice position count from the end
                        let newStr = str.slice(-6);
                            // negative count starts from -1, 
                            // returns a new string => "string"

                4. str.toLowerCase(); // "this is a string"
                5. str.toUpperCase(); // "THIS IS A STRING"

                    * capitalize a string 
                        const str = "pRotick";
                        const strLower = str.toLowerCase();
                        const strCapitalized = str[0].toUpperCase() + strLower.slice(1); 
                            // strCapitalized === "Protick"
                    
                    * comparing emails 
                        i)   Convert it to lower case 
                        ii)  Remove white spaces 
                        iii) compare 


                6. str.trim(); 
                    // removes white spaces and \n from start and end of a string 
                    
                    i) str.trimStart() // from start 
                    ii) str.trimEnd()  // from end 


                7. str.replace('what to replace', 'with what');
                    // replaces the first occurance and returns a new string

                    // to replace all matching occurance you can use regex 
                        str.replace(/This/g, 'dis');
                            // here 'g' denotes global flag for the regex expression enclosed by / /

                8. str.replaceAll('This', 'Dis');
                    // replaces all the 'This' word with 'Dis' in the string 'str'
                    // returns a new string 
                
                
                    const plane = 'Air320neo';
                9. plane.includes('Air320'); // returns true (or false)
                10. plane.startsWith('Air'); // returns true (or false)
                11. plane.endsWith('320');   // returns true (or false)
                
                    const x = 'a+very+nice+string'; 
                12. const words = x.split('+');         // split
                        // returns an array of strings 
                        // words === [ 'a', 'very', 'nice', 'string' ];
                    
                13. let joinedString = words.join(' '); // join
                    // returns new string by joining array elements by parameter passed to .join() method 
                    // joinedString === 'a very nice string' 

                14. Padding a string 
                    let str = 'This is a line of text';

                    let paddedStr = str.padStart(30, '+');
                    let paddedStr = str.padEnd(30, '-');

                    let emptyPadStrStart = str.padStart(30, ' ');
                    or, 
                    let emptyPadStrStart = str.padStart(30);

                        // returns new string after adding padding, 
                        // total length of the new string including padding will be exactly 30 characters 
                
                15. Repeat a string n times. 
                    str.repeat(n);
                    // returns a new string repeating 'n' times;
                
        </p>

        <h2>Numbers Dates Timers and Internationalizations</h2>
        <p>
            * Number 
                1. All numbers are represented as floating point numbers or decimals no matter 
                    if we write them as integers
                    console.log(10 === 10.0) // true

                2. Numbers are 64 bit base 2
                3. Certain numbers are very difficult to represent in binary such as 0.1
                    console.log(0.1 + 0.2) // 0.30000000000000004 [Confusion 5]
                    console.log( 0.1 + 0.2 ==== 0.3 ) // false [Confusion 6]

                * JavaScript can not really do precise sceientific calculation even if it also tires to round off number
                    behind the scene. 
                
                * String to Number conversion 
                    1. Number('23') // 23
                    2. +'23'        // 23 , by coercion 
                
                
                * Parsing 
                    works with string that starts with numeric characters
                        Number.parseFunction('25String', radix or base); 
                        radix 
                            An integer between 2 and 36 that represents the radix (the base in mathematical 
                            numeral systems) of the string. Be careful—this does not default to 10.

                    Integer
                        * Number.parseInt('30px', 10)       // 30
                        * Number.parseInt('30.5rem', 10)    // 30
                        * Number.parseInt('e23', 10)        // NaN 

                    Float 
                        * Number.parseFloat('250.50rem') // 250.50
                        * parseFloat('250.50rem') // also works but Number.parseFloat() is encouraged. 

                * Check if Not A Number (NaN)
                    both NaN == NaN and NaN === NaN evaluate to false. [Confusion 7]
                    The isNaN() function provides a convenient equality check against NaN.
                    * Number.isNaN('2')             // false
                    * Number.isNaN(Number('str'))   // true
                    * Number.isNaN( 23 / 0 )        // true

                Rather check for if the number is finite, that returns expected value if a value is a number or not
                * Check if a value is a Number
                    * Number.isFinite(10)       // true
                    * Number.isFinite('10')     // false    it is a string 
                    * Number.isFinite(+'20X')   // false    it is NaN 
                    * Number.isFinite(10 / 0)   // false    it is Infinity
                    
                * Check if a value is an Integer 
                    * Number.isInteger(10)      // true
                    * Number.isInteger(10.0)    // true
                    * Number.isInteger('20')    // false    it is string 
                    * Number.isInteger(10.5)    // false    it is double and has decimal point values 
                    * Number.isInteger(10 / 0)  // false    it is infinity

                    *** Important 
                        https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
                        [Confusion 8]


                * JavaScript has singular concept of number values which is called 'number', 
                    let x = Number.parseFloat(10.1);
                    let y = Number.parseInt(10.1);
                    typeof x === typeof y
                    >> true [Confusion 9]

                * Infinity value 
                    there is a special mathematical value in JavaScript which is 'Infinity'
                * Note: typeof NaN === 'number' // true

                * Numeric Seperator (ES 2021)
                    _ (underscore) to seperate numeric characters in a number to enhance readablity 
                    
                    conditions: 
                        1. always between two digits 
                        2. not start or not at the end and not before or after the decimal point 
                        3. not two or more consecutive underscores
                    
                    * Number('230_000')     // NaN  only works with numbers not strings 
                    * parseInt('230_000')   // 230  ignores the rest after the numeric seperator after 
                                            // the underscore as it is a string

                * BigInt (ES 2020) (primitive)
                    Numbers are 64 bits of which 53 bits are used to store the number and the rest are used to 
                    store the position of the decimal point.

                    * Biggest Number JavaScript can represent, (safely)
                        console.log( 2 ** 53 - 1) // -1 because 0 is also a number // 9007199254740991
                        the max number is also stored in Number.MAX_SAFE_INTEGER in Number namespace 

                    * To represent and work with big numbers which are more than 53 bits long we can use 'n' with it
                        let bigIntNumber = 90071992547409919007199254740991n;

                        we can also create a bigInt by, 
                        let bigIntNumber = BigInt(90071992547409919007199254740991n)

                    * Operations
                        we can perform all the operations same as regular numbers but we can not mix them 
                            1. console.log(90071992547409919007199254740991n * 2n); // okay
                            
                            2. console.log(90071992547409919007199254740991n * 2); // Exception
                                solution 
                                console.log(90071992547409919007199254740991n * BigInt(2));

                        Exceptions: 
                            1. console.log(20n > 15);       // true     because it type coerce the 20n to 20
                            2. console.log(20n === 20);     // false    because strict equality does not type coerce 
                               console.log(20n == 20);      // true     because it type coerce 
                               
                            3. console.log( 20n + 'is really huge') // 20 is really huge 
                            
                            4. Math library functions do not work with bigint 

                            5. console.log( 10n / 3n )      // 3n               cuts the decimal part off 
                               console.log( 10 / 3 )        // 3.3333333333333

                *** Internationalization of Numbers 
                    https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat

                    let num = 123456.789;
                    let options = {
                        style: 'unit',      // 1. 'unit'    
                                            // 2. 'currency',      
                                            // 3. 'percent' (when used 'unit' is ignored)
                        unit: 'celsius', 
                        currency: 'BDT',    // when style: 'currency'
                        useGrouping: false, // default is 'true'
                        maximumSignificantDigits: 3 // for people who counts in lacs and crores not millions
                    };
                    let localizedNumber = new Intl.NumberFormat(locale, options).format(num);


            * Dates
                * Creating dates - 4 Ways 
                    1. Current date and time 
                        new Date();                         // current date time timezone 

                    2. parse date from a date string 
                        new Date('June 10, 2021');          // not so reliable 

                    3. new Date by providing - year, month, date, hour, minute, seconds 
                        new Date(2021, 5, 10, 16, 45, 30);  // Month is 0 based, 0 - 11 

                    4. timestamp 
                        Milliseconds passed after initial UNIX time - 1st January 1970
                        new Date(0);                        // Thu Jan 01 1970 06:00:00 GMT+0600 
                                                            // (Bangladesh Standard Time)

                    * Date auto corrects itself meaning, if you provide 31 days for the month of November to 
                        the Date() constructor it will automatically corrects itself by adjusting the month and day
                        to December 1.

                * Date is also an object so we get methods 
                    let today = new Date();
                    let now = Date.now();

                    1. today.getFullYear();     // .getYear() is also available but not recommended to use. 
                    2. today.getMonth();        // 0 - 11, because Month is 0 based in JavaScript [Confusion 9]
                    3. today.getDate();         // day of the month [Confusion 10]
                    4. today.getDay();          // day of the week  [Confusion 11]
                    5. today.getHours();
                    6. today.getMinutes();
                    7. today.getSeconds();
                    8. today.toISOString();     // 2022-06-14T11:59:00.389Z
                    9. today.getTime();         // 1655207940389 // timestamp from a date
                    10. Date.now();             // 1655208063477 // timestamp of the moment

                    * Set methods are also available to set year month date hours minutes seconds 
                    * Set methods also auto corrects 

                *** 'Month' to and 'Month' from 'Date()' constructor returns 0 - 11 
                    On the other hand, ISOString from the date and ISOString to the Date() constructor is always 1 - 12 
                    [CONFUSION 12] 
                        let date1 = new Date('2020-07-26T12:01:20.894Z');
                        let date2 = new Date(2020, 06, 26)
                            // check for the month, it is the same in the output - July

                *** Internationalizing dates using locale 
                    let locale = navigator.language;    //  to get locale from user's browser, 
                                                        //  you can also specify it directly like 'bn_BD'
                    let options = {
                        hour: numeric, 
                        minute: numeric, 
                        day: 'numeric', 
                        month: 'long', 
                        year: 'numeric', 
                        weekday: 'long'
                    };

                    let localDate = new Intl.DateTimeFormat(locale, options).format(date);

                        1. new Intl.DateTimeFormat(locale, options) this part creates a formatter 
                        2. on the formatter we call format() method with a date that needs to be formatted. 

                    * You can omit 'options' argument if you do not want hour and minutes

            * Timers 
                Timeout 
                * setTimeout(() => console.log('I am called later'), 1000);
                    1. JavaScript will simply call setTimeout function as it is encountered in source code and the 
                        setTimeout function will register the callBack to be executed after specified time.
                    2. and the execution simply continues without waiting for the specified time and executes the 
                        following statements. This mechanism is called Asynchronous JavaScript

                    * passing arguments to callback function 
                        setTimeout(function(arg1, arg2), 4000, argToPass1, argToPass2);

                    * Cancel the timer - before time has elapsed
                        let someTimer = setTimeout((arg1, arg2) => console.log(arg1, arg2), 4000, ...[arg1, arg2]);
                            clearTimeout(someTimer);

                Interval
                * let interval = setInterval(function(){
                        let now = new Date();
                        console.log(`${now.getHours()}:${now.getMinutes()}:${now.getSeconds()}`);
                    }, 1000);

                * clear interval timer
                    clearInterval(interval);


        </p>        


        <h2>Dom and events </h2>
        <p>
            * DOM - Document Object Model : Structured representation of HTML document. 
                    It is a very complex API with a lot of methods and properties to interact with the DOM Tree.

            * DOM Tree - A tree structure that represents a family tree, where "document" is the 
                first parent / root / entry point 

                    document --> html --> head --> title --> text
                                  |         
                                  |
                                 body --> section --> nav --> ul --> li --> text 
                                  |
                                  |
                                main --> p --> text 
                                  
                whatever is in the html also has to be in the DOM. 
                DOM also includes CSS styles. 

            * Every DOM elements or nodes are objects that has properties such as, innerHTML, textContent, style etc.
            * Every single node of the DOM tree of type Node and each Node is represented by an Object. These Nodes 
                get access to special Node methods and properties such as, .childNodes, .parentNode, .cloneNode(), 
                .textContent
            * Node also has types such as Element, Text, Comment, Document
                                          <p></p>  text  <!---->  
            * Each Element has a child type of HTMLElement which consists of HTMLButtonElement ... HTMLDivElement. 
            * HTMLElement is a child of Element and also Node so it inherits all properties and methods from both 

            * Adding callback on events 
                * document.querySelector('query').addEventListener('event', callbackFunction () {});
                * document.element.addEventListener('event', callbackFunctionValue);
                * document.getElementById('element id without the # ').addEventListener('event', callback);

            * Changing styles of elements 
                * document.querySelector('body').style.backgroundColor = 'green';

            * Add, remove, check, toggle class of an element via
                
                * document.querySelector('.element-class').classList.add('paragraph__text--white'); 
                    // adds specified class, if the class has already been added to that element, do nothing. 

                * document.querySelector('.element-class').classList.remove('paragraph__text--white'); 
                    // removes specified class if present on the selected element or do nothing if not. 

                * document.querySelector('.class').classList.contains('.another-class'); 
                    // returns true or false if "another-class" is present in the selected element. 
                
                * document.querySelector('#id').classList.toggle('active'); 
                    // toggles the specified class "active"; adds or removes it from the selected element. 

                
            * querySelector vs querySelectorAll 
                * querySelector only selects the first matching occurance in the dom and returns the element.
                * querySelectorAll selects all matching occurance in the dom and return an array of elements. 

            * Selecting an element via getElementById is a little faster than querySelector. 

            * The DOM and DOM methods are part of the WEB APIs, they are not part of JavaScript. 
            
            *** Not just rely on the DOM to hold our data, make data relevant to application 
                always to be available in the code. 

            * In DOM 
                1. 'document' is the supreme parent Node which is not of element type. 
                2. we can select the whole document element (whole HTML) by 'document.documentElement' to 
                    operate on the whole documentElement such as applying styles and such.

                        * document                  === <!DOCTYPE html> <html> ... </html>
                        * document.documentElement  === <html> ... </html>
                        * document.head             === <head> ... </head>
                        * document.body             === <body> ... </body>

                        for these special elements we dont need to write any selectors. 

                Selecting Element 

                1. document.querySelector('.selector')      === single element
                    document.querySelectorAll('.selector')  === Node list of elements 

                2. document.getElementById('id-name')       === return single html element object that has id = 'id-name'
                
                3. document.getElementsByTagName('button') === returns a HTMLCollection of elements 
                    HTMLCollection is different from Node List because HTMLCollection is also called Live Collection 
                    meaning it changes when element in the DOM changes. The collection gets updated automatically 
                    as DOM changes

                4. document.getElementsByClassName('class-name') === returns HTMLCollection of elements

                Creating Element 

                1.  Creating and adding live element
                    const message = document.createElement('div');
                    message.classList.add('cookie-message');
                    message.innerHTML = `we use cookies for improved functionality and analytics 
                                        <button class="btn btn--close-cookie"> Accept all</button>`;

                    i)  header.prepend(message);    // add element as first child of the parent element 
                    ii) header.append(message);     // add element as last child of the parent element. 

                    * we can not simultaniously add single live element multiple times.  
                        in this case we are prepending it first and then appending it later which results in 
                        removing first prepended element and then appending it later. Basically moves the live element
                        from start to the end. 
                    
                        * Any single DOM element is unique 

                    * we can however create a single element and add it multiple times by copying it 
                        header.append(message.cloneNode(true)); 
                        // argument 'true' denotes that also copy the child elements of the element that is being cloned 

                    * we can also add sibling elements to selected element by 
                        iii) header.before(message);
                        iv) header.after(message);

                2. create the markup and insert in the DOM by,
                    v) parent.insertAdjacentHTML('beforeend', element-markup');
                    vi) parent.insertAdjacentText('beforeend', text);
                

                * Delete Elements 
                    // recent feature
                    1. selectedElement.remove();
                    2. this.parentNode.remove();
                    
                    // old feature                     
                    3. selectedElement.parentElement.removeChild(selectedElement);

                * Style element 
                    selectedElement.style.propertyInCamelCase = 'value-in-string';
                    let msg = document.querySelector('.cookie-message');
                    
                    // set style
                    msg.style.backgroundColor = '#37383d';
                    msg.style.width = '120%';

                    * these styles are added as inline styles 

                    // get styles 
                        1. inline styles 
                            msg.style.backgroundColor 

                        2. external stylesheet styles or internal styles 
                            let obj = getComputedStyle(selectedElement); 
                            // returns CSSStyleDeclaration (JavaScript) object

                            then we can get style property and value by 
                            obj['property']; 
                            
                            or,
                            getComputedStyle(selectedElement).color

                    // manipulate styles 
                        let element = document.querySelector('.element-class');
                        element.style.height = Number.parseFloat(getComputedStyle(element).height, 10) + 30 + 'px';
                
                        // why 10 is not type coerced to string as we are adding 'px' to it ?
                        // because + operators associativity is from left-to-right. [check MDN]
                        // so first 10 is added to the calculated height and then 'px' is added to that value 
                        // and then finally set to the element's height property

                * Changing CSS custom properties 
                    document.documentElement.style.setProperty('--name-of-our-custom-property', 'desired-value');
                    * setProperty() method can also be used to set/change any styles on the webpage 
                
                * Attributes 
                    let logo = document.querySelector('.nav__logo');
                    logo.attribute 
                    // e.g.,                     
                        logo.alt 
                        logo.src
                
                    * element.className; // not element.class for historical reasons

                    * standard attributes for an element will be automatically created based on Node type but 
                        JavaScript will not create attributes that are not standard for the element type. 
                        for example suppose we have an img element like this, 
                            <img src="./image.png" alt="some alternate text" class="some-img" 
                                data-version-number = '1.0.1' designer="Protick">

                        // get attribute
                        now if we try to access/get 'designer' attribute which is not standard for img element 
                            let imgEl = document.querySelector('.some-img');
                            imgEl.designer // returns undefined 

                        however we can access a non-standard attribute by, 
                            imgEl.getAttribute('designer'); // returns Protick
                        
                        * img.src                   // returns absolute URL 
                        * img.getAttribute('src')   // returns relative URL
                        * same is true for href attribute for anchor 'a' element

                        // set attribute
                        logo.alt = 'Beautiful Minimalist logo';
                        logo.setAttribute('alt', 'Beautiful Minimalist logo');


                * Data attributes 
                    data attributes are special kind of attribute that starts with 'data' prefix such as, 
                    data-version-number = '1.0.1'
                    1. data attributes are stored in 'dataset' object 
                    2. to access data attribute we need to convert following words to camelCase like, 
                        console.log(img.dataset.versionNumber);
                    
                * Classes 
                    selectedElement.classList.add('', '');
                    selectedElement.classList.remove('');
                    selectedElement.classList.toggle('');
                    selectedElement.classList.contains('');

                    *** Do not use this, because it overwrites all class name with provided one
                        selectedElement.className = 'class-name';

            * Scroll - scroll position, smooth scrolling, sticky navigation
                1. Position of current scroll 
                    console.log('current scroll (x/y): ', window.pageXOffset, window.pageYOffset);
                    x in px from left to right of the viewport
                    y in px from top to bottom of the viewport

                2. Position and size of an element 
                    element.getBoundingClientRect();
                    // returns a DOMRect object which contains position and size of the element 
                    {
                        bottom: 31.390625
                        height: 29
                        left: 99.5
                        right: 209.5
                        top: 2.390625
                        width: 110
                        x: 99.5
                        y: 2.390625
                    }

                3. visible viewport height and width 
                    console.log('current viewport height / width :', 
                                document.documentElement.clientHeight, document.documentElement.clientWidth);
                
                4. scroll to the position 
                    window.scrollTo(section1Coords.left, section1Coords.top);
                    scrolls to a particular set of coordinates in the document.                    
                    // section1Coords.top is relative to the viewport not the document itself 
                
                5. Scroll to the position with respect to the whole document 
                    window.scrollTo(
                        Number.parseFloat(section1Coords.left + window.pageXOffset),
                        Number.parseFloat(section1Coords.top + window.pageYOffset)
                    );

                6. Smooth scrolling
                    // old way 
                    window.scrollTo({
                        left: section1Coords.left + window.scrollX,
                        top:  section1Coords.top + window.scrollY,
                        behavior: 'smooth',
                    });

                    // new way 
                    section1.scrollIntoView({behavior: 'smooth'});

                    *** also smooth scrolling can be activated by using css property in css 
                    html {
                        scroll-behavior: smooth;
                      }
                    
                7. Sticky navigation based on 'scroll' event 

                    window.addEventListener('scroll', function(e){
                        const initialCoord = section1.getBoundingClientRect().top;
                        if(window.scrollY > initialCoord)
                        nav.classList.add('sticky');
                        else
                        nav.classList.remove('sticky');
                    });

                8. Sticky navigation using Intersection Observer API
                
                    // first parameter is intersection entries, second is the IntersectionObserver Object itself
                    const obsCallBack = function (entries, observer) {
                        entries.forEach(function (entry){
                        console.log(entry);
                        });
                    };
                    
                    const obsOptions = {
                        root: null,     // 'null' denotes the viewport itself, 
                        threshold: 0.1  // also accepts array [0, 0.1, 0.2] each entry denotes a ratio, 
                                        // 0.1 menas 10% of the viewport in this case. 
                      };                // Ratio increases from top to bottom. 
                                        // intersection happens when our target 'section1' element in 
                                        // this case enters within 10% of the viewport 
                    
                    const observer = new IntersectionObserver(obsCallBack, obsOptions);
                    observer.observe(section1);
                  
                    * sample IntersectionObserver API's Object looks like this, 
                        IntersectionObserverEntry {
                            boundingClientRect: DOMRectReadOnly {x: 0, y: 145, width: 1349, height: 1517.25, top: 145, …}
                            intersectionRatio: 0.10479485988616943
                            intersectionRect: DOMRectReadOnly {x: 0, y: 145, width: 1349, height: 159, top: 145, …}
                            isIntersecting: true
                            isVisible: false
                            rootBounds: DOMRectReadOnly {x: 0, y: 0, width: 1349, height: 304, top: 0, …}
                            target: section#section--1.section
                            time: 14878.5
                            [[Prototype]]: IntersectionObserverEntry
                        }
                    
                    * the callBack function is called twice when target enters or exits the threshold of the root element

                    * Sticky Navigation 

                        const stickyNav = function (entries, obsObj) {
                            const [entry] = entries;
                            if( ! entry.isIntersecting )
                                nav.classList.add('sticky');
                            else 
                                nav.classList.remove('sticky');
                        };
                        
                        // header is being observed
                        const headerObserver = new IntersectionObserver(stickyNav, {
                            root: null,
                            threshold: 0,       // when 0 percent of the header is visible here, 
                                                // then we want something to happen 
                            rootMargin: '-90px' // root is shortened by 90px; from all the sides, 
                                                // top, right, bottom, left. 
                        });
                        headerObserver.observe(header);

                        * incase you want to get height of an element, 
                            const navHeight = nav.getBoundingClientRect().height;
                    

                9. Revealing Elements on scroll using IntersectionObserver API. 
                    const reavealOnScroll = function (entries, observer) {
                        const [entry] = entries;
                        if (!entry.isIntersecting) return;
                        entry.target.classList.remove('section--hidden');
                        observer.unobserve(entry.target);
                    };
                    
                    const sectionObserver = new IntersectionObserver(reavealOnScroll, {
                        root: null,
                        threshold: 0.15,
                    });
                    
                    const allSections = document.querySelectorAll('.section');
                    allSections.forEach(function (sec, i) {
                        sectionObserver.observe(sec);
                        sec.classList.add('section--hidden');
                    });
                

                10. Lazy load image when user near to an image
                    const loadImg = function (entries, observer) {
                        const [entry] = entries;
                    
                        if(!entry.isIntersecting) return;
                    
                        const src = entry.target.getAttribute('data-src');
                        entry.target.setAttribute('src', src);
                        entry.target.addEventListener('load',function (e){
                        entry.target.classList.remove('lazy-img');
                        });
                        observer.unobserve(entry.target);
                    };
                    
                    const imgObserver = new IntersectionObserver(loadImg, {
                        root: null, 
                        threshold: 0,
                        rootMargin: '200px'
                    });
                    
                    const imgTargets = document.querySelectorAll('img[data-src]');
                    imgTargets.forEach(function (img) {
                        imgObserver.observe(img);
                    });

            * Events fired at page load 
                1. 'DOMContentLoaded' event on the document fired when all HTML CSS and JS is loaded and DOM tree 
                    is generated 
                2. 'load' event on the 'window' after all the resources are loaded for the page. 
                3. 'beforeunload' on the 'window' when the page is about to be exited and in the event handler for 
                    this event must return event.returnValue = ''; for historical reasons  
                    

            * DOM traversing 
                travelling through the DOM tree by selecting elements relative to other element. 
                
                    1. select parent element first 
                        const h1 = document.querySelector('h1');

                // going downwards: selecting child element 
                    1. use querySelector on parent element and provide child elements query, 
                        const spans = h1.querySelectorAll('.highlight');
                        
                        * go as much deep as its direct children tree goes. 
                        * but will not select sibling element or their children. 

                    2. select all child elements 
                        h1.childNodes
                            * returns all child nodes including html comments 
                    
                    3. all children elements
                        h1.children
                            * returns live HTMLCollection of all elements 
                            * works only for direct children 

                    4. first element child 
                        h1.firstElementChild

                    5. last element child
                        h1.lastElementChild 


                // going upwards: Selecting parent element 
                    1. selecting direct parent node
                        h1.parentNode

                    2. selecting direct parent element 
                        h1.parentElement 

                    3. select closest parent element 
                        h1.closest('.header').style.background = 'var(--gradient-secondary)';
                            * very important for event delegation 
                            * finds the closest parent element whereas querySelector selects the closest child 
                
                // going sideways 
                    we can only select immediate previous and immediate next sibling element of an element 
                    1. h1.previousElementSibling
                    2. h1.nextElementSibling
                    
                    we can also access sibling nodes 
                    1. h1.previousSibling
                    2. h1.nextSibling

            * Events 
                * An event is just a signal generated by a DOM node that something has happened. 
                * An event happens as user interacts with the document irrespective of if we have an hander to 
                    respond to that or not. 

                * Event listing 
                    https://developer.mozilla.org/en-US/docs/Web/Events

                * keyboard events: they are global events because they do not happen on one specific event 
                    so we listen to the whole document 
                    
                    document.addEventListener('keydown', function (ev) {
                        if ( ev.key === 'Escape') {
                            statements;
                        }
                    });

                * which key is pressed is stored on the event itself.
                * when an event occurs JS call the callback function / event listener and passes the 
                    event as an argument to it. Inside the callback function the 'this' keyword always refers to 
                    the element itself by default but you can change that with 
                    callbackFunction.bind(obj);

                * event.target returns the element that dispatched the event 
                * event.currentTarget returns the current element that is being active after event is dispatched. 

                * adding event listener 
                    let h1 = document.querySelector('h1'); 

                    1. via 'addEventListener', 
                        h1.addEventListener('mouseenter', function(){
                            console.log('attaching event handler via addEventListener');
                        });

                    * more modern than 'on event property' 
                        also its advantages over to the prior is that we can add multiple event handler to the 
                        same event for an element whereas 

                    * if we try to do the same with the 'on event property' then the later event handler
                        overwrites the previous event handler function 

                    * also we can remove event listener from an element by 
                        to remove a event handler from an element we need to attach a named function first
                            let eventHandler = function (e) {
                                console.log('named function');
                            };

                            h1.addEventListener('click', eventHandler);
                            h1.removeEventListener('event', eventHandler);
                    
                    2. via 'on event property'                
                        h1.onmouseenter = function () {
                            console.log('attaching event handler via on event propter');
                        };

                    3. via inline 'on event property'
                        *** this method of attaching event handler to a element on a event should not be used. 

            * Event Propagation (Capturing -> Target -> Bubbling phase)
                1. When an event is generated by the DOM it is generated at the root to the target element 
                    then the 'capturing phase' happens and then the event travels down the tree it will pass through
                    every single parent element of the target element. 

                2. As soon as the event reach the target then the 'target phase' begins when events can be 
                    handled right at the target.

                3. After reaching the target the event travels all the way up through all the parents to the root 
                    again in the so called 'bubbling phase'. Bubbling phase is important for event delegation
                
                *** this whole process of event travelling through parents and target is called event propagation.
                
                4. By default, event can only be handled in the target and in the bubbling phase but we can set up 
                    event listeners in a way that they listen to capturing phase instead. 

                5. Not all kind of events have bubbling and capturing phase. Some of them are created right on the 
                    target element and we can only handle them there. 

                6. The event never passes through any sibling elements. 

                7. As if the event happened in all the parent elements as event bubbles up from target element 
                
                8. in an event handler 'this' always points to the element to which the event handler is attached              
                
                9. this === event.target === event.currentTarget 
                    // only for the element which actually generates the event and 
                    // also if the event handler attached to it is being called, in that function the 
                    // above statement should return true
                
                10. this === event.currentTarget  // true for parent elements's event handler 
                
                11. event.stopPropagation();      // stops event from propagating to parent elements
                    // in practice, stopPropagation() is not a good idea. 
                
                12. you can also capture an event in capturing phase when event is travelling down from root to target 
                    element through all the parent elements by setting the third parameter to true in the 
                    addEventListener method call. 
                        h1.addEventListener('event', callback, true)
                    
                    we generally do not capture an event in capturing phase but it exists for historical reasons. 

            * Event Delegation 
                In case you are repeatating the same callback function for multiple elements 
                attach a event handler to the common parent of all child elements and handle the event from there
                this process is called event delegation. 

                    document.querySelector('.nav').addEventListener('click', function(e){
                        e.preventDefault();
                        const id = e.target.getAttribute('href');
                        document.querySelector(id).scrollIntoView({behavior: 'smooth'});
                    });

                *** hardest part of using this technique is to come up with a matching strategy in case we dont 
                    want to perform operation on the generated event from an child element that we do not want. 

            * Passing argument to event handlers 
                we can not really pass arguments to handler functions but we can use bind() method on it to 
                set this keyword to desired argument value or we can also bind 'this' to an object. 
                and the first parameter that a event handler gets is the event itself which is passed to it 
                by JavaScript itself. 
        </p>


        <h2>Libraries and methods</h2>
        <p>
            Math
                * Math.random() => 0.0000 to 0.9999
                
                * generate a random number between 1 to 6, 
                    Math.trunc(Math.random() * 6) + 1; // Math.trunc() truncates the decimal part 

                * Math.abs( -100 ) => 100

                * square root 
                    Math.sqrt(25)   // 5

                    the same can also be done by, 
                    25 ** (1/2)     // 5

                * Cubic root 
                    8 ** (1/3)      // 2

                * Maximum value 
                    Math.max(5, 8, 23, 11, 2)   // 23
                    * also type coerce the values from strings to numbers
                    * does not do parsing such as, from string to numbers 
                
                * Minimum value 
                    Math.min(5, 8, 23, 11, 2)   // 2

                * Math library also has some constants such as, 
                    Math.PI === 3.141592653589793

                * Generalized random integer generator function
                    const randomInt = (min, max) => Math.floor( Math.random() * (max - min) + min);            
                
                * Rounding Integers
                    * All of these methods do type coercion such as string to number

                    Round to nearest integer
                        Math.round(23.3)    // 23
                        Math.round(23.9)    // 24

                    Ceilling to Integer 
                        Math.ceil(23.3)     // 24
                        Math.ceil(23.9)     // 24

                    Flooring to Integer 
                        Math.floor(23.3)    // 23
                        Math.floor(23.9)    // 23
                        Math.floor(-23.3)   // -24  for negative values floor rounds down 

                    Truncate the decimal part 
                        Math.trunc(23.3)    // 23
                        Math.trunc(23.9)    // 23
                        Math.trunc(-23.3)   // -23

                * Rounding decimals 
                    (2.7).toFixed(0)    // '3'      always returns a string not a number 
                    (2.7).toFixed(3)    // '2.700'  pads remaining decimal points with '0'
                    (2.345).toFixed(2)  // '2.35'   same as flooring and ceilling in mathematics
                    +(2.345).toFixed(2) // 2.35     convert the result to a number 
            
            Geolocation Browser API 
                navigatior.geolocation.getCurrentPosition(successCallback, failureCallBack);
                
            Leaflet Libray for map and coorordinates 

            Local Storage Browser API (Blocking Asynchronous process)
                to store data into browser
                * localStorage.setItem('key', string value);
                * localStorage.getItem('key');
                * localStorage.removeItem('key');
            
            Location 
                location.reload();

            Navigator 
                navigator.locale

            JSON 
                JSON.stringify(obj);                    // to JSON string 
                    // does not reatains the prototype chain of the original object and only stringyfies properties. 

                JSON.parse('JSON sting of an object')   // to generic JavaScript Object 
            
        </p>


        <h2>How JS works behind the scene</h2>
        <p>
            * Just in time compiled language so, each statement is parsed and compiled to machine code 
                and executed immediately by JS Engine 

            * Execution steps
                1. Parse and create AST (Abstract Syntax Tree)
                2. Compile to binary 
                3. Execution in call stack 
                4. Optimize and return to step 2

            * JS Engine 
                1. HEAP 
                2. Call Stack 

            * JS Runtime (See below)
                JS Engine + WEB APIs + Callback Queue

            * Steps 
                1. Exactly One global execution cotext is created (creation phase)
                2. All top level code or code that are outside of any function are executed in the global 
                    Execution Context
                3. One execution context per function call is created (creation phase) and placed in the call 
                    stack and executed then pop out the execution context when the function returns ( or execution is 
                    finished for the Execution Context )
                4. After all the function are done executing the engine will keep waiting for callback functions 
                    to arrive. 

            * Execution Context 
                Environment in which a piece of JavaScript is executed. Store all the necessary information for some
                code to be executed. 

                An EC consists of, 
                    1. Variable Environment (VE) => let, const, var, function, arguments, objects 
                    2. Scope Chain 
                    3. this => value of this keyword for the context 

                    all these elements that make up the EC are generated during creation phase
                    
                    *** EC for arrow function do not get "arguments" objet and "this" keyword.

            * Scoping 
                JavaScript uses lexical scoping, meaning scoping is controlled by placement of functions and 
                blocks in the code. 
                Scoping is how program's variables are organized and accessed. 

                * scope: 
                    space or environment in which certain variable is declared 
                    There are 3 types of scope, 
                        1. global scope - outside of any function or block; accessible everywhere. 
                        2. function scope - inside function, also called local scope and variables declared inside it 
                                are called local variables. 
                        3. Block scope (ES2015) - Only applies to let and const variables. Functions are also block 
                            scoped. Function declared inside a block is only accessible inside that block. 

                        * Variables declared with 'var' are function scoped or the global scoped 

                * scope chain: 
                    Every scope has access to all the variables of it's (outer) parent's scope.     
                    This rule also applies to function parameters. 
                
                * Variable look up: 
                    If one scope need to access a variable and it is not present in the current scope then it 
                    will look up in the scope chain and see if it can find the variable in one of its parent's scope. 

                * Parent scope does not access child scope. 
                * Scope chain also applies to block scope. 
                * Variables with same name in current scope overrides variables from parent's scope. 

            * Hoisting 
                Before execution, code is scanned for variable declartions and for each variable a new property is 
                created in the Variable Environment Object of the Execution Context.

                * let, const variables and function expression or arrow functions that are stored in a variable 
                    that is declared with let and const are placed in Temporal Dead Zone (TDZ).
                    That is why we can not use them prior to declration. On the other hand, we can invoke 
                    function that uses a function declaration syntax and also variables that are 
                    declared with 'var' keyword. 

                * TDZ 
                    Temporal Dead Zone starts at the begining of the scope and end at the line it is defined. 

                    * why TDZ ? 
                        1. Makes it easier to avoid and catch errors. 
                        2. Makes const variables actually work. 
                        we can not declare an empty const variable. 

                * Why hoising ?
                    1. to make functions accessible that uses function declaration syntax. ***
                    2. var hoisting is just a byproduct. 
                    
                * 'var' variables are hoisted with 'undefined' value. 
                * 'var' variables are created as a property on the global 'window' object. 

                * function expression / arrow functions declared with var will be hoisted and value set 
                    to those variables are 'undefined'
                    => undefined(); // imagine what will happen. 

                * Pitfall of hoisting 
                    if you use 'var' variables as condition parameter prior to definition. 

            * 'window' is the global object of JavaScript in the browser, each per window. 

            * The 'this' keyword
                special variable that is created for every execution context (EC).

                1. In event listener / event callback => this === 'the element itself on which the listener 
                    is bind to'
                2. obj.method() => this === obj (on which the method is called) 
                3. Function with declrative syntax in global scope => this === 'undefined'
                4. Arrow function => this === 'this of the function's parent'

                * without strict mode 'this == window'
            
            * Everything related to DOM is not actually a part of JavaScript but they are are part of the WEB API 
                So it is in the WEB API's environment, task related to DOM will execute. Asynchronous task such as, 
                timers, ajax calls, dynamic image load are offloaded to the WEB API's environment. 

            * JavaScript is single threaded meaning, only one task can be executed at once so how JavaScript 
                executes code asynchronously ?
                JavaScript implements Non-Blocking concurrency model using the web api's environment and event loop.

            
            * JavaScript (browser) Runtime
                1. HEAP - an area of memory where objects are stored
                2. Call Stack - where codes are executed; works like a stack of execution context which are executed
                    from top to bottom of the stack and after an execution context finishes execution it is popped off
                    the stack. 

                    1 + 2 => JavaScript Engine. 

                3. WEB APIs and its environment 
                    WEB API such as DOM, Timers, Fetch API etc, these APIs are made available to the JS engine so 
                    that we can use them to interact with the DOM, make ajax calls, set timers and so on. 
                    JavaScript itself has no sense of time instead web api's environment manges such functionality 
                    and makes them available for use to the JS engine.

                4. Callback queue
                    all the callback functions that were attached to an event or to an asynchronous task are placed 
                    at the last of this queue as soon as the event gets triggered or an asynchronous task is finised. 

                5. Microtask queue 
                    same as Callback queue but this queue only holds callback functions for promises and has 
                    priority over the Callback queue. 

                6. Event loop 
                    An internal manager that loads the callback functions from callback queue and multitask queue into 
                    the callstack.
                    When a callback function is loaded from the queue into the callstack we say that operation as 
                    a 'Event Loop Tick'.

                *** 1 + 6 => JavaScript Runtime for Browser. A container that includes all the neccessary components 
                    to run the JavaScript codes. 


            * How the 'JavaScript concurrency model' works ?
                1. Everything related to DOM is not really part of the JavaScript but of the WEB API's.
                    It is in he WEB API's environment asynchronous task related to the DOM will run and same 
                    is true for all asynchronous tasks.

                2. Register the 'callback-to-the-event/asynchronous-task' that is to be executed when the event is 
                    triggered or the asynchronous task is finised. 

                3. Offload the asynchronous task of fetching an api to the WEB API's environment and register the 
                    associated callback-to-the-promise in the same environment. 

                4. when an asynchronous task is finished and related event is fired then the callback function will be
                    put in the Callback queue or in the Microtask queue in case of promises. 

                5. Callback/Microtask queue is an ordered list of all the callback functions that are in line to be 
                    executed. 

                6. Callback functions are placed at the last of the queue and wait for its turn to be executed. 
                    e.g., callback of a setTimeout(function(){ console.log('More than 5 seconds passed')}, 5000);
                            will be put on the callback queue after 5 seconds. 

                    * Timer's duration is not a guarantee that your callback will be executed the moment it 
                        passes 5 seconds mark but it is guaranteed that the callback will not be executed 
                        before 5 seconds. 

                7. Callback Queue also contains callback for other DOM events such as, click, key presses 
                    which are not really asynchronous behavior but they still use callback queue to run their 
                    attached callbacks.

                8. How and What Event Loop does ?
                    a) It looks into the callstack and determines wheather it is empty or not except ofcourse for 
                        the global execution context. 

                    b) If the stack is indeed empty which means that there is no code being executed then it will 
                        take the first callback from the microtask queue if there is none then it will take the 
                        first callback from the callback queue and put that into the callstack to be executed and 
                        this is called a tick.
                        
                        Event loop does the orchestration of this entire JS runtime.

                    c) JavaScript language itself has no sense of time that becase everything that is asynchronous
                        does not happen in the JavaScript Engine but in the runtime which manages all the asynchronous 
                        behavior and it is the event loop who decides which code will be executed next. 
                        The engine itself executes whatever code is given. 

                    * callbacks / asynchronous codes are deferred into future which we only want to be executed once 
                        the 'asynchronous task' is finished. 
                        
                9. callbacks related to promises are called micro tasks are moved from web api's environment to the 
                    micro task queue which has priority over the callback queue. 

        </p>

        
        <h2>Asynchronous JavaScript: Promises, Async, Await, fetch and AJAX</h2>
        <p>
            * Synchronous execution: 
                Line by line top to bottom statements are executed in 'Execution thread', which is part of the 
                Execution context. Each line of code waits for the previous line to finish execution. 

            * Asynchronous execution: 
                Asynchronous code (often written inside callback) is executed after a asynchronous task that 
                runs in the background finishes.

                Asynchronous code is non-blocking.

            * Execution does not wait for an asynchronous task to finish its work. 

            * Example, 
                1. setTimeout(function(){console.log('hello')}, 4000);
                    the setTimeout() register an asynchronous task of waiting 4 seconds before 
                    asynchronous code written in the callback executes. 

                2. imageElement.src = 'path/to/image.jpg' 
                    image loaded asynchronously in the background and when it finishes the 'load' event is triggered. 
                    if you bind a callback to that event then that callback contains asynchronous code with respect 
                    to the normal flow of single threaded execution 

            * AJAX - Asynchronous JavaScript And XML
                * Request
                    GET, POST, PUT, PATCH, DELETE - HTTP requests made from a client to a server that contains 
                    
                    1. A start-line describing the requests to be implemented, or its status of whether successful or 
                        a failure. This start-line is always a single line.
                   
                    2. An optional set of HTTP headers specifying the request, or describing the body included in 
                        the message. A blank line indicating all meta-information for the request has been sent.
                   
                    3. An optional body containing data associated with the request (like content of an HTML form), 
                        or the document associated with a response. The presence of the body and its size is specified 
                        by the start-line and HTTP headers.
                    
                    The start-line and HTTP headers of the HTTP message are collectively known as the head of the 
                        requests, whereas its payload is known as the body.

                * Response 
                    Made from server to a client that contains, 
                    1. Status line
                        The start line of an HTTP response, called the status line, contains the following information:
                            a) The protocol version, usually HTTP/1.1.

                            b) A status code, indicating success or failure of the request. 
                                Common status codes are 200, 404, or 302

                            c) A status text. A brief, purely informational, textual description of the status 
                                code to help a human understand the HTTP message.

                            e.g,  HTTP/1.1 404 Not Found.

                    2. Header
                        HTTP headers for responses follow the same structure as any other header: 
                        a case-insensitive string followed by a colon (':') and a value whose structure 
                        depends upon the type of the header. The whole header, including its value, presents 
                        as a single line.

                    3. Body
                        The last part of a response is the body. Not all responses have one: responses with a 
                        status code that sufficiently answers the request without the need for corresponding 
                        payload (like 201 Created or 204 No Content) usually don't.

                        Bodies can be broadly divided into three categories:
                    
                        a) Single-resource bodies, 
                            consisting of a single file of known length, defined by the two headers: 
                            Content-Type and Content-Length.

                        b) Single-resource bodies, 
                            consisting of a single file of unknown length, encoded by chunks with 
                            Transfer-Encoding set to chunked.

                        c) Multiple-resource bodies, 
                            consisting of a multipart body, each containing a different section of information. 
                            These are relatively rare.

                * How request response packets are transmitted in client to server model
                    1. First TCP/IP socket connection is established between client and server.
                    2. Then client makes a request to the server with neccessary payload. 
                    3. Then HTTP message are divided into packet and each packet contains the destination IP 
                        via different routes they reach the destination and assembled to the HTTP message 
                        as per protocol

                
            * API 
                Application Programming Interface. Piece of software that can be used by another piece of software
                in order to allow application to talk to each other. 

            * API data formats 
                XML, JSON

            * WEB API
                Generally API that are hosted on a live server is called WEB APIs 

            * How to make an AJAX call 
                1. old way 
                    let request = new XMLHTTPRequest();
                    request.open('GET', apiUrl);
                    request.send();

                    request.addEventListener('load', function(e){
                        const [data] = JSON.parse(request.responseText);
                        console.log(data);
                    });
                
                2. fetch API 
                    fetch('url').then((response) => response.json()).then((data) => console.log(data));

            * fetch API and Promises
                * Promise states 
                    1. Pending: Before any value resulting from the asynchronous task is available.
                    2. Settled: Asynchronous task is finised 
                        it can have either of the following two values: 
                            1. Fulfilled: no error thrown while executing the asynchronous task and 
                                the promise returned a value other than an error 
                            2. Rejected: an error occurred while executing the asynchronous task. 

                    * A promise is only settled once and from there its state is unchanged. 
                
                * fetch() - builds and returns a promise 

            * consuming a promise 
                1. chain then() method to the promise 
                    fetch('url').then((response) => return response.json()).then((data) => console.log(data));
                    
                    * then() always returns a promise, no matter if we actually return anything or not from 
                        that method. 

                    * if we do return a value from a 'then' method then that value become the 'fulfillment value'

            * Handling rejected promise
                1. via rejectCallBack 
                    promise.then(successCallBack(result){}, rejectCallBack(error){});
                
                2. with catch() method 
                    promise.then().catch((err) => console.log(err))
                    catch() method also returns a promise 

                * Any error within a promise will result into the promise being rejected. 

            * Creating a promise
                Promises are a special kind of object that is used as a placeholder for the future result of an 
                asynchronous task.  

                const promise = new Promise(executorFunctionCallBack(resolve, reject){
                    if(yourCondition)
                        resolve('fulfillment value');
                    else 
                        reject('rejected value or new Error("Error message")');
                });

            * Promisifying 
                wrap old callback based functions in promises. Callback based asynchronous behavior into promise based
                asynchronous behavior. 
            
            * with promises you can create a chain of asynchronous behavior in sequence. 

            * Create a resolved or rejected promise immediately 
                Promise.resolve('fulfillment value');
                Promise.reject('rejected value');
                
            * Promisify geolocation api 
                const getLocation = () => {
                    return new Promise((resolve, reject) => {
                    navigator.geolocation.getCurrentPosition(resolve, reject);
                    });
                };
                getLocation().then(position => console.log(position)).catch(err => console.log(err.message));

            * Consuming promises with async and await (ES2017)
                * async function: a funciton that will keep running in the background while performing the code inside
                    of it. Then when the function is done it automatically returns a promise. The asynchronous task 
                    is loaded off to the background. 

                * await: inside async function that halts execution of the following statment until the current 
                    statement that is marked with the await keyword finishes execution. 

                * async await: just syntatic sugar over consuming promises. they are also used with more 
                    traditional then() method. 
                
                * to use await inside a callback function we have to declare the callback as async function

            * Notes on async await: 
                1. async function always returns a promise 
                2. top level await is not permitted, it is only permitted within an async function.
                3. use async IIFE and await promise within the function body
                4. re-throw error from async function's try catch to handle that in other scope with async await.

            * settled promise: means a value if available, it does not matter if the promise is rejected or fulfilled. 
                
            * Promise combinators: all, allSettled, race, any 

                1. Promise.all([]) 
                    * Running promises in parallel 
                        which will run all the promises in the array at the same time and saves valuable load time. 
                        const promiseResponses = Promise.all(['array of promises']);

                    * Promise.all([]) - short circuits when any promise of that input promise array rejects. 
                    
                    * returns a new promise, if one of the promises rejects then the whole promise that is returned by 
                        Promise.all() method, get rejected. 

                2. Promise.race([])
                    * returns a promise which is settled as soon as one of the input promises is settled, does not care
                        about if the race winner promise is actually fulfilled or rejected. 
                        
                    * If the winning promise is a fulfilled promise then the fulfillment value of the promise returned 
                        by the race() method will be the fulfillment value of the winning promise. 

                    * Promise.race([]) short circuits whenever one of the promises is settled, no matter it is 
                        fulfilled or rejected. 

                    * In real world, Promise.race() is very useful against promises that takes too long or never 
                        ending promises. 
                        race against a timer,

                            const timeout = function (sec) {
                                return new Promise(function(_, reject){
                                    setTimeout(()=>{
                                        reject(new Error('Request took too long!'));
                                    }, sec * 1000);
                                });
                            };
                            
                            Promise.race([
                            getJSON(`https://restcountries.com/v2/name/tanzania`),
                            timeout(1),
                            ])
                            .then(data => {
                                console.log(data[0]);
                            })
                            .catch(err => {
                                console.error(err.message);
                            });

                3. Promise.allSettled([])
                    * returns a promise that resolves after all of the given promises have either fulfilled 
                        or rejected, with an array of objects that each describes the outcome of each promise.

                    * never short circuits 

                4. Promise.any([])
                    * returns 'first fulfilled promise' as the fulfillment value of the returned promise by any()
                    * Ignores rejected promises 
                    * Always returns a fulfilled promise unless ofcourse all of them are rejected. 

                
        
                    
        </p>

        <h2>Modern JavaScript Development: Modules, Tooling and Functional Programming</h2>
        <p>
            * 3rd party modules aka packages. 
            * node package manager (npm)
            *   development -> 
                building (webpack or parcel) -> 
                transpiling and polyfilling (babel) -> 
                production (JavaScript bundle)

            * Module
                Module is a reusable peiece of code that encapsulates implementation details of a certain part 
                of our project. 

            * Module is usually a standalone file but it does not have to be. 
            * Module has imports and exports 
                1. with export we can export values out of a module, whatever we export from a module is called 
                    public api. 
                2. with import we can imort modules into other modules. Modules being imported are called dependency.

            * Benefits of modules: 
                1. Makes it easy to compose software. Module can be considered as small building blocks that we 
                    put together to build complex application. 
                2. isolate components: modules can be developed in isolation without thinking about the
                    entire codebase. 
                3. abstract code: implement low level code in modules and import these abstractions into other modules. 
                    You can import and use what you need or want without thinking or caring about why or how it 
                    works behind the scene. 
                4. Organized code: naturally lead to more organized code bases. 
                5. Reusability: allow us to easily reuse the source code even across multiple projects. 
            
            * ES6 Modules: 
                1. Modules are stored in files, exactly one module per file. 
                2. ES6 Module v/s script 
                    Top Level variable:
                        Scoped to module. Variables are private to the module, only exported values can be used
                        -/-
                        all top level variables are always global which leads to global namespace pollution 
                        and varibable name collision

                    Default mode:
                        strict -/- sloppy

                    Top level 'this': 
                        undefined -/- 'window' object

                    imports and exports: 
                        Yes, all imports are hoisted automatically -/- No support for import and export
                    
                    HTML linking
                        type='module' attribute with script tag
                        -/-
                        type='text/javascript' attribute with script tag
                    
                    Downloading module file
                        Asynchronous by HTML 
                        -/-
                        Synchronous unless 'defer' or 'async' is used
            
            * How importing actually work 
                1. Parsing - read the code without executing it, at this stage imports are hoisted. The whole process
                    of importing modules happen before the code in main module is executed. 

                2. index.js - module imports the math.js and dom.js module in a synchronous way, what that means is, 
                    only after the imported module have been downloaded and executed the main index.js module will 
                    finally be executed as well. This is only possible because top level imports and exports. 

                3. Top level imports and exports makes building and dead code elimination possible. 

                4. Downloading of modules happens asynchronously and importing happens synchronously. Then after 
                    the module arrives it is also parsed then the module's exports are linked to the 
                    imports in index.js. 
                    link between imort and export is a live link, so exported values are not copied to imports instead
                    the import is just a pointer. So when the value changes in the exporting module then the same value
                    also changes in the importing module. This feature is unique to ES6 modules. 
                    
            * File that contains modules should be named in camelCase notaion as per convention. 

            * If you import a module inside a script then you have to implement that script inside html using script 
                tag with type attribute set to 'module', or else it will not work. 

            * How to export from a module 
                1. named export 
                    const aVariable = 10;

                    a) export const addToCart = function () {

                        };
                    
                    b) export { aVariable as avar };
                    * if you do not want to rename the export as you are exporting it just omit the
                        'as avar' part. 

                2. default export 
                    export default function () {
                        console.log('I am a default export');
                    }
                    * Usually we use default exports when we only want to export one thing per module. 

            * How to import a module or part of it 
                1. import 'named export' 
                    import { namedExport as chosenName } from 'path/to/module.js';
                    * if you do not want to rename the export as you importing it just omit the 'as chosenName' part. 

                2. import 'defautl export'
                    import anyChosenName from 'path/to/module.js';

                3. import all 
                    import { * as anyChosenName } from 'path/to/module.js';
                    and then to use exports you have to,
                    anyChosenName.exportName 
                
                * in case you are using a module bundler like webpack or parcel you can omit the full path and 
                    just write the module name such as, 
                    import { namedExport } from 'module';

                
                4. import 'named export' and 'default export' at once, 
                    import defaultName , { namedExport } from 'path/to/module.js';

            * Export always need to happen in top level code

            * However we do not import multiple time from a single module and also do not import default and named 
                export in a single statement. 

            * Top level await (ES2022)
                'await' outside of an async function 
                1. Only works in modules.
                2. await halts code execution of following statements 
                3. if a module imports another module that has top level await inside it then the code execution 
                    halts at that point in that module and also in the module that is imorting it. 

            * The module pattern 
                before ES6 modules were available 

                1. we start by writing a function IIFE 
                2. return an object that holds the public api to that IIFE closure. 
                3. store the result of the IIFE in a variable 
                4. save all of the above in a script file and load that via HTML and use the functionality 
                    via the container variable from step 3.

                    const someModule = (function (){
                        const cart = [];
                        const someFunction = function (value) {
                            cart.push(value);
                        };
                        return { someFunction };
                    })();

            * CommonJS module: 
                node.js uses CommonJS module until recently

                /* Commonjs module */
                module system used in node.js, this syntax is not supported by JavaScript in the browser. 

                // export
                
                    export.addToCart = function (product, quantity) {
                        cart.push({ product, quantity });
                        console.log(`${quantity} ${product} added to cart`);
                    };
                
                // import
                   const { addToCart } =  require('./shoppingCart.js');

            * Introduction to NPM 
                1. npm -v
                2. npm init (at project root)
                3. fill out information or skip with 'enter' key
                4. npm install package-name
                5. npm install (to install all project dependencies)
                6. npm install package-name --save-dev (install development dependencies)
                7. npm install package-name -g (install a package globally)
                8. npm install package-name@1.12.4 (install exact version)

            * Building with parcel 
                1. install parcel 
                    npm install parcel --save-dev
                
                2. build from terminal 
                    npx parcel index.html (or entry point to your application)
                
                3. build from terminal using a npm script 

                    package.json > scripts section 
                    "build": "parcel build index.html"

                    in terminal run, 
                    npm run build

                
            * Install parcel in windows 10
                1. stop live-server 
                2. npm cache clean --force
                3. npm install parcel --save-dev 
                4. always read the error message

            * Most of the module at npm repository are CommonJS module, we can not use them without a module bundler
                because export and import syntax used in CommonJS module is different and it is not supported 
                by browser runtime but it is supported by node.js 
            
            * To use a module/package without a module bundler the module must be implemented with ES6 module syntax
                so that we can import them in our project. 
                e.g., 
                import cloneDeep from './node_modules/lodash-es/cloneDeep.js';

            * Parcel and hot module replacement 
                Parcel is a zero configuration module bundler.
                
                Hot module replacement: 
                    update module changes in the browser without reloading the whole page and retaining application 
                    state. 
                    Only parcel understands the following code and removes it while bundling and serving the bundle 
                    to the webpage. 

                    if(module.hot){
                        module.hot.accept();
                    }
 
            
            * Including / importing module syntax with build tools such as parcel
                no need to specify the entire path to any module. 
                import cloneDeep from 'lodash-es';

                * this even works with all kind of assets such as HTML, CSS, image, sass files and also all kind of 
                    modules. 

                * you can use all CommonJS modules in a similer way you use ES6 module with parcel. 

            * Transpiling and polyfilling 
                Transpiling: convert modern syntax to old javascript version 
                    such as arrow function are converted to function expression
                    npm package - 'babel' does transpiling and parcel automatically uses it while 
                    building the application

                Polyfilling: Modern javascript features such as promise, async function and such which can not be 
                    transformed to older javascript syntax
                    in root script of your application, 
                    import 'core-js/stable';                // for find(), promise
                    import 'regenerator-runtime/runtime';   // for async functions

            * Imperative v/s declarative programming paradigms. 
                Imperative: 
                    How to do things. 
                    we explain the computer every single step it has to follow to achieve a 
                    result. e.g., step by step recipe of a cake. 

                    const arr = [1, 2, 3];
                    for (let i = 0; i < arr.length; i++){
                        arr[i] = arr[i] * 2;
                    }
                    // how to double every element of the array

                Declarative: 
                    what to do.
                    we simply describe the way the computer should achieve the result, the how (step by step 
                    instructions) gets abstracted away. 
                    e.g., description of a cake. 
                    
                    const doubledArr = arr.map(entry => entry * 2);

                    * 'functional programming' is a sub-paradigm of declrative programming. 
                    
            * Functional programming 
                1. Declarative programming paradigm. 

                2. Based on the idea of writing software by combining namey pure functions avoiding side effects and 
                    mutating data. 

                3. Side-effect: modification of any data outside of the function (mutating external variables, 
                    logging to console, writing to DOM etc.)
                
                4. Pure-function: function without any side effects and does not depend on external variables.
                    Given the same input always returns the same output. 

                5. Immutability: state (data) is never modified instead, state is copied and the copy is 
                    mutated and returned. 
                    The big upside of immutability is it makes it so much easier to keep track of how the data flows
                    through our entire application and so ultimately that will allow us to write better code with 
                    less bugs and more readable code which is the goal of using functional programming. 
                    Library that uses functional programming, react, redux. 

                * we are allowed to mix imperative and declarative programming in our own code. 
                * Make data structure immutable 
                    Object.freeze(arr);
                    freezes first level of the object. Does not freeze object inside the object. Not a deep-freeze. 

                * Composing / currying: 
                    Create the chain of operation

                * Pass all the data to a function that it needs so that, if does not rely on any outside data. 
                * Data transformation function in javascript that are most used in functional programming which 
                    do not have side effects. 
                    map(), filter(), reduce()
                *** Any program needs to have side effects otherwise what is the use of a program. 
                    
                * Modern JS clean code guidelines: 
                    Readablity 
                    1. write code so that others can understand it.
                    2. write code so that you can understand it in 1 year. 
                    3. avoid too 'clever' and overcomplicated solutions. 
                    4. use descriptive variable names: 'what they contain'
                    5. use descriptive function names: 'what they do'

                    General 
                    6. Use DRY principle(refactor your code).
                    7. Do not pollute global namespace, encapsulate instead. 
                    8. Do not use 'var'
                    9. use strong type checks (=== and !===)

                    Functions
                    10. Generally function should do only one thing. 
                    11. Do not use more than 3 function parameters. 
                    12. use default parameters whenever possible. 
                    13. generally return same data type as received. 
                    14. use arror functions when they make code more readable.

                    OOP
                    15. use ES6 classes. 
                    16. Encapsulate data and do not mutate it from outside the class. 
                    17. implement methods chaining, return object from methods. 
                    18. do not use arrow function as methods (in regular objects)

                    Avoid nested code 
                    19. use early return (guard clause)
                    20. use ternary(conditional) or logical operators instead of 'if else'
                    21. use multiple 'if' instead of 'if else-if'
                    22. avoid for loop use array methods instead. 
                    23. avoid callback-based asynchronous API 

                    Asynchronous code 
                    24. consume promises with async/await for best readability. 
                    25. whenever possible, run promises in parllel (Promise.all) 
                    26. Handle errors and promise rejection

                    Functional programming techniques 
                    27. Try to avoid data mutations 
                    28. Use built-in methods that do not produce side effects
                    29. Do data transformations with methods such as .map(), .filter(), .reduce()
                    30. Try to avoid side effects in functions: this is of course not always possible
                    
                    Declarative syntax 
                    31. use array and object destructuring 
                    32. use the spread operator, (...)
                    33. use the ternary operator 
                    34. use template literals. 
                    
        </p>

        <h2>Important general information</h2>
        <p>
            * Enabling strict mode
                'use strict';

                enabling strict mode will prohibit you from using variable without declaration with let const or var.
                also reserves a set of keywords that are decided to be implemented in future version of JS

            * transpile and polyfill JS source code with babel to support older browser upto browsers from 2009 or ES5; 
            * Statement: unit of a instruction set.
            * Expression: Operation that produces value. 

            * which data structure to use
                collection of data --> data structure --> (simple list) --> (manipulate ordered data) --> Array 
                                               |                 |
                                               |                 |
                                               |         ( high performance, unique data ) --> Set
                                               |
                                        (key value pairs)
                                               |
                                               |
                                               |--> (easy to write)     --> Object 
                                               |--> (easy to iterate)   --> Map 

                * Data from WEB APIs are almost always JSON formatted that is similar to JS Object. 
                * Array of Objects are more comon. 
                * we should use array or sets to store a list of items and when we do not need to describe them. 
                * Use array when we need to manipulate list items and there are tons of useful array methods. 
                * Use Set when we need list of only unique elements
                * Use Set when high performance is really important
                * Use Set to remove duplicate items from Array
            
            * Object V/S Map 
                1. Object 
                    * when we need to include functions. 
                    * when working with JSON. 
                    * when key/properties must be a string. 
                    * Easy to access values with . and []
                
                2. Map 
                    * When you need to simply map key to values and you dont need any method in it at any point. 
                    * when you need keys to be of any type such as string number boolean object function array set etc. 
                    * Map iteration
                        for (const [key, value] of mapObj){

                        }

            * Why method call on primitive type such as 'string' works ?
                Because of "Boxing"

            * Boxing
                Boxing is wrapping a primitive type value inside an object when JS engine sees a method call on a
                primitive type value it wraps it in an appropriate object and performs the method call and then finally
                returns the resultant primitive value. 

            * In EU , is used as decimal seperator. 
            * In US . is used as decimal seperator.

            * Different ways to load script into a webpage 
                1. 'async' attribute in script opeing tag 
                    loads script asynchronously but does not gurantted to be executed in order 
                    'DOMContentLoaded' event is fired irrespective of async script is finised loading 

                2. 'defer' 
                    gurantted execution of scripts in order and DOMContentLoaded fired after 'defer' 
                    scripts are loaded

            * Load libraries first then your own script 
            * Load script in the head with defer attribute so it provides best load time and DOM generation 
            
            * // prettier-ignore 
                ignores the following statement while formatting.

            * CORS - cross origin resource sharing 
            * API Endpoints - api urls
            * github-public-apis
            * Callback hell: 
                Nested callback functions that are set to execute one inside/after another which leads to poor readablity 
                understanding and maintainability. To solve this proble JavaScript introduced 'promise'.

            * object property accessor '.' always resolve from left to right.
            * console.error(err.message);

        </p>


        <h2>Development Debugging and Problem solving tips</h2>
        <p>
            Problem solving techniques: 

                * Ask right questions until you understand what is really being asked for, 
                    figure out the result you really want to achive
                    understand the input and output first then figure out the path from input to output.
                * Divide and conquer, divide the entire problem into sub problems
                * Research and solve sub-problems until you hit a wall, if you do, google. 
                * Write pseudo code / comments / sentence (what you want to happen in steps) before coding. 
                * Draw flowchart before coding.


            Debugging: 

                * VScode has a built in JS debugger use it to set breakpoints and step through statements. 
                * chrome dev tools > source > breakpoint -> debug (sometimes does not stop at breakpoint)
                * add the following statement in the source code to halt execution
                    debugger; 
                    or, 
                    debug(functionName);

                * console.warn();
                * console.error();
                * console.table(obj);
                * console.dir(functionValue):

                debugging framework
                    1. Identify bug -> automated tests 
                    2. Find bug -> finding the underlying reason => logical, structural etc
                    3. Fix bug 
                    4. Prevent bug

            * How to plan a web project ? 
                1. User stories: 
                    Description of the application's functionality from the user's perspective . All the user stories
                    put together describes the entire application. 

                    User story format: 
                        * As a [type of user], I want [an action] so that [a benefit]. 
                            who - what - why 

                        example,
                            1. As a 'user' I want 'to log my running workout with location, distance, time, pace and 
                                steps/minute' So I 'can keep a log of all my running'
                            2. As a 'user' I want to 'log my cycling workouts with location, distance, time, speed and 
                                elevation gain' So I can 'keep a log of all my cycling'.

                2. Features 
                    Required fetures that user of an application need and also internal features that need to be 
                        implemented to make the application work based on events / interaction with the application.
                        example, 
                            Map, Geolocation, Workout Form, store workout data in storage.  

                3. Flowchart 
                    What we will build 

                    Draw a flowchart based on events and what operations each event meant to trigger and also the 
                    expected results. 

                4. Architecture
                    How we will build it. 

                    i) Structuring the Data 
                        One of the most important aspect of an architecture is to decide where and how to store the data
                        based on the decision how data will be stored we design the application architecture.
                        if we want to implement the whole application architecture using OOP we can use 
                        Class Architecture - Draw Class Diagram 

                        
                    ii) Structuring the Code 
                        separate 'data class' and 'application class' and their inheritance chain 
                        so that our concerns are seprated.

                        Application Class should create and use Data Class object to operate but 
                        their inheritance chain should be seperated. Also application class should handle 
                        user interaction and respective UI rendering. 

                        For simple to medium sized application this architecture should be enough.


                    iii) For complex application, we can further divide the 'Application class' from presious step ii) 
                        into two classes of which 1 will be responsible for holding application data and 
                        related behaviors (Business Logic)
                        and other 1 will be responsible for rendering the UI and related behaviors

                5. Development 

                *** Step 3 and 4 need not to be perfect at the first go before we start development. It can be perfected
                    over time as we build the application.

        </p>

        </pre>
    </main>
    <script src="script.js"></script>
</body>
</html>
